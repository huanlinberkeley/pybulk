# Bias-independent calculations
if (self.TYPE == self.ntype):
    self.devsign = 1
else:
    self.devsign = -1

# Constants
self.epssi    = self.EPSRSUB * self.EPS0
self.epsox    = self.EPSROX * self.EPS0
self.Cox      = self.EPSROX * self.EPS0 / self.TOXE
self.epsratio = self.EPSRSUB / self.EPSROX

# Physical oxide thickness
if ("TOXP" not in param.keys()):
    self.BSIMBULKTOXP = (self.TOXE * self.EPSROX / 3.9) - self.DTOX
else:
    self.BSIMBULKTOXP = self.TOXP
self.L_mult = self.L * self.LMLT
self.W_mult = self.W * self.WMLT
self.Lnew = self.L_mult + self.XL
if (self.Lnew <= 0.0):
    print("Fatal: Ldrawn * LMLT + XL = %e for %M is non-positive", Lnew)
self.W_by_NF = self.W_mult / self.NF
self.Wnew    = self.W_by_NF + self.XW
if (self.Wnew <= 0.0):
    print("Fatal: W / NF * WMLT + XW = %e for %M is non-positive", Wnew)

# Leff and Weff for I-V
self.L_LLN      = self.Lnew**-self.LLN
self.W_LWN      = self.Wnew**-self.LWN
self.LW_LLN_LWN = self.L_LLN * self.W_LWN
self.dLIV       = self.LINT + self.LL * self.L_LLN + self.LW * self.W_LWN + self.LWL * self.LW_LLN_LWN
self.L_WLN      = self.Lnew**-self.WLN
self.W_WWN      = self.Wnew**-self.WWN
self.LW_WLN_WWN = self.L_WLN * self.W_WWN
self.dWIV       = self.WINT + self.WL * self.L_WLN + self.WW * self.W_WWN + self.WWL * self.LW_WLN_WWN
self.Leff       = self.Lnew - 2.0 * self.dLIV
if (self.Leff <= 0.0):
    print("Fatal: Effective channel length = %e for  %M is non-positive", Leff)
elif (self.Leff <= 1.0e-9):
    print("Warning: Effective channel length = %e for %M is <= 1.0e-9. Recommended Leff >= 1e-8", Leff)
self.Weff = self.Wnew - 2.0 * self.dWIV
if (self.Weff <= 0.0):
     print("Fatal: Effective channel Width = %e for %M is non-positive", Weff)
elif (self.Weff <= 1.0e-9):
    print("Warning: Effective channel width = %e for %M is <= 1.0e-9. Recommended Weff >= 1e-8", Weff)

# Leff and Weff for C-V
self.dLCV = self.DLC + self.LLC * self.L_LLN + self.LWC * self.W_LWN + self.LWLC * self.LW_LLN_LWN
self.dWCV = self.DWC + self.WLC * self.L_WLN + self.WWC * self.W_WWN + self.WWLC * self.LW_WLN_WWN
self.Lact = self.Lnew - 2.0 * self.dLCV
if (self.Lact <= 0.0):
     print("Fatal: Effective channel length for C-V = %e for %M is non-positive", Lact)
elif (self.Lact <= 1.0e-9):
    print("Warning: Effective channel length for C-V = %e for %M is <= 1.0e-9. Recommended Lact >= 1e-8", Lact)
self.Wact = self.Wnew - 2.0 * self.dWCV
if (self.Wact <= 0.0):
    print("Fatal: Effective channel width for C-V = %e for %M is non-positive", Wact)
elif (self.Wact <= 1.0e-9):
    print("Warning: Effective channel width for C-V = %e for %M is <= 1.0e-9. Recommended Wact >= 1e-8", Wact)

# Weffcj for diode, GIDL etc.
self.dWJ    = self.DWJ + self.WLC / self.Lnew**self.WLN + self.WWC / self.Wnew**self.WWN + self.WWLC / self.Lnew**self.WLN / self.Wnew**self.WWN
self.Weffcj = self.Wnew - 2.0 * self.dWJ
if (self.Weffcj <= 0.0):
    print("Fatal: Effective channel width for S/D junctions = %e for %M is non-positive", Weffcj)
self.Inv_L     = 1.0e-6 / self.Leff
self.Inv_W     = 1.0e-6 / self.Weff
self.Inv_Lact  = 1.0e-6 / self.Lact
self.Inv_Wact  = 1.0e-6 / self.Wact
self.Inv_Llong = 1.0e-6 / self.LLONG
self.Inv_Wwide = 1.0e-6 / self.WWIDE
self.Inv_WL    = self.Inv_L * self.Inv_W

# Effective length and width for binning
self.L_LLN1 = self.L_LLN
self.L_WLN1 = self.L_WLN
if (self.DLBIN != 0.0):
    if (self.DLBIN <= -self.Lnew):
        print("Fatal: DLBIN for %M = %e is <= -Ldrawn * LMLT", DLBIN)
    else:
        self.L_LLN1 = (self.Lnew + self.DLBIN)**-self.LLN
        self.L_WLN1 = (self.Lnew + self.DLBIN)**-self.WLN
self.W_LWN1 = self.W_LWN
self.W_WWN1 = self.W_WWN
if (self.DWBIN != 0.0):
    if (self.DWBIN <= -self.Wnew):
        print("Fatal: DWBIN for %M = %e is <= -Wdrawn * WMLT", DWBIN)
    else:
        self.W_LWN1 = (self.Wnew + self.DWBIN)**-self.LWN
        self.W_WWN1 = (self.Wnew + self.DWBIN)**-self.WWN
self.LW_LLN_LWN1 = self.L_LLN1 * self.W_LWN1
self.dLB         = self.LINT + self.LL * self.L_LLN1 + self.LW * self.W_LWN1 + self.LWL * self.LW_LLN_LWN1
self.LW_WLN_WWN1 = self.L_WLN1 * self.W_WWN1
self.dWB         = self.WINT + self.WL * self.L_WLN1 + self.WW * self.W_WWN1 + self.WWL * self.LW_WLN_WWN1
self.Leff1 = self.Lnew - 2.0 * self.dLB + self.DLBIN
if (self.Leff1 <= 0.0):
    print("Fatal: Effective channel length for binning = %e for %M is non-positive", Leff1)
self.Weff1 = self.Wnew - 2.0 * self.dWB + self.DWBIN
if (self.Weff1 <= 0.0):
    print("Fatal: Effective channel width for binning = %e for %M is non-positive", Weff1)
if (self.BINUNIT == 1):
    self.BIN_L = 1.0e-6 / self.Leff1
    self.BIN_W = 1.0e-6 / self.Weff1
else:
    self.BIN_L = 1.0 / self.Leff1
    self.BIN_W = 1.0 / self.Weff1
self.BIN_WL         = self.BIN_L * self.BIN_W
self.VFB_i          = self.VFB + self.BIN_L * self.LVFB + self.BIN_W * self.WVFB + self.BIN_WL * self.PVFB
self.VFBCV_i        = self.VFBCV + self.BIN_L * self.LVFBCV + self.BIN_W * self.WVFBCV + self.BIN_WL * self.PVFBCV
self.NSD_i          = self.NSD + self.BIN_L * self.LNSD + self.BIN_W * self.WNSD + self.BIN_WL * self.PNSD
self.NDEP_i         = self.NDEP + self.BIN_L * self.LNDEP + self.BIN_W * self.WNDEP + self.BIN_WL * self.PNDEP
self.NDEPCV_i       = self.NDEPCV + self.BIN_L * self.LNDEPCV + self.BIN_W * self.WNDEPCV + self.BIN_WL * self.PNDEPCV
self.NGATE_i        = self.NGATE + self.BIN_L * self.LNGATE + self.BIN_W * self.WNGATE + self.BIN_WL * self.PNGATE
self.CIT_i          = self.CIT + self.BIN_L * self.LCIT + self.BIN_W * self.WCIT + self.BIN_WL * self.PCIT
self.NFACTOR_i      = self.NFACTOR + self.BIN_L * self.LNFACTOR + self.BIN_W * self.WNFACTOR + self.BIN_WL * self.PNFACTOR
self.CDSCD_i        = self.CDSCD + self.BIN_L * self.LCDSCD + self.BIN_W * self.WCDSCD + self.BIN_WL * self.PCDSCD
self.CDSCB_i        = self.CDSCB + self.BIN_L * self.LCDSCB + self.BIN_W * self.WCDSCB + self.BIN_WL * self.PCDSCB
self.DVTP0_i        = self.DVTP0 + self.BIN_L * self.LDVTP0 + self.BIN_W * self.WDVTP0 + self.BIN_WL * self.PDVTP0
self.DVTP1_i        = self.DVTP1 + self.BIN_L * self.LDVTP1 + self.BIN_W * self.WDVTP1 + self.BIN_WL * self.PDVTP1
self.DVTP2_i        = self.DVTP2 + self.BIN_L * self.LDVTP2 + self.BIN_W * self.WDVTP2 + self.BIN_WL * self.PDVTP2
self.DVTP3_i        = self.DVTP3 + self.BIN_L * self.LDVTP3 + self.BIN_W * self.WDVTP3 + self.BIN_WL * self.PDVTP3
self.DVTP4_i        = self.DVTP4 + self.BIN_L * self.LDVTP4 + self.BIN_W * self.WDVTP4 + self.BIN_WL * self.PDVTP4
self.DVTP5_i        = self.DVTP5 + self.BIN_L * self.LDVTP5 + self.BIN_W * self.WDVTP5 + self.BIN_WL * self.PDVTP5
self.K2_i           = self.K2 + self.BIN_L * self.LK2 + self.BIN_W * self.WK2 + self.BIN_WL * self.PK2
self.K1_i           = self.K1 + self.BIN_L * self.LK1 + self.BIN_W * self.WK1 + self.BIN_WL * self.PK1
self.XJ_i           = self.XJ + self.BIN_L * self.LXJ + self.BIN_W * self.WXJ + self.BIN_WL * self.PXJ
self.PHIN_i         = self.PHIN + self.BIN_L * self.LPHIN + self.BIN_W * self.WPHIN + self.BIN_WL * self.PPHIN
self.ETA0_i         = self.ETA0 + self.BIN_L * self.LETA0 + self.BIN_W * self.WETA0 + self.BIN_WL * self.PETA0
self.ETAB_i         = self.ETAB + self.BIN_L * self.LETAB + self.BIN_W * self.WETAB + self.BIN_WL * self.PETAB
self.DELTA_i        = self.DELTA + self.BIN_L * self.LDELTA + self.BIN_W * self.WDELTA + self.BIN_WL * self.PDELTA
self.U0_i           = self.U0 + self.BIN_L * self.LU0 + self.BIN_W * self.WU0 + self.BIN_WL * self.PU0
self.UA_i           = self.UA + self.BIN_L * self.LUA + self.BIN_W * self.WUA + self.BIN_WL * self.PUA
self.UD_i           = self.UD + self.BIN_L * self.LUD + self.BIN_W * self.WUD + self.BIN_WL * self.PUD
self.EU_i           = self.EU + self.BIN_L * self.LEU + self.BIN_W * self.WEU + self.BIN_WL * self.PEU
self.UCS_i          = self.UCS + self.BIN_L * self.LUCS + self.BIN_W * self.WUCS + self.BIN_WL * self.PUCS
self.UC_i           = self.UC + self.BIN_L * self.LUC + self.BIN_W * self.WUC + self.BIN_WL * self.PUC
self.PCLM_i         = self.PCLM + self.BIN_L * self.LPCLM + self.BIN_W * self.WPCLM + self.BIN_WL * self.PPCLM
self.PCLMCV_i       = self.PCLMCV + self.BIN_L * self.LPCLMCV + self.BIN_W * self.WPCLMCV + self.BIN_WL * self.PPCLMCV
self.RSW_i          = self.RSW + self.BIN_L * self.LRSW + self.BIN_W * self.WRSW + self.BIN_WL * self.PRSW
self.RDW_i          = self.RDW + self.BIN_L * self.LRDW + self.BIN_W * self.WRDW + self.BIN_WL * self.PRDW
self.PRWG_i         = self.PRWG + self.BIN_L * self.LPRWG + self.BIN_W * self.WPRWG + self.BIN_WL * self.PPRWG
self.PRWB_i         = self.PRWB + self.BIN_L * self.LPRWB + self.BIN_W * self.WPRWB + self.BIN_WL * self.PPRWB
self.WR_i           = self.WR + self.BIN_L * self.LWR + self.BIN_W * self.WWR + self.BIN_WL * self.PWR
self.RSWMIN_i       = self.RSWMIN + self.BIN_L * self.LRSWMIN + self.BIN_W * self.WRSWMIN + self.BIN_WL * self.PRSWMIN
self.RDWMIN_i       = self.RDWMIN + self.BIN_L * self.LRDWMIN + self.BIN_W * self.WRDWMIN + self.BIN_WL * self.PRDWMIN
self.RDSW_i         = self.RDSW + self.BIN_L * self.LRDSW + self.BIN_W * self.WRDSW + self.BIN_WL * self.PRDSW
self.RDSWMIN_i      = self.RDSWMIN + self.BIN_L * self.LRDSWMIN + self.BIN_W * self.WRDSWMIN + self.BIN_WL * self.PRDSWMIN
self.PTWG_i         = self.PTWG + self.BIN_L * self.LPTWG + self.BIN_W * self.WPTWG + self.BIN_WL * self.PPTWG
self.PDIBLC_i       = self.PDIBLC + self.BIN_L * self.LPDIBLC + self.BIN_W * self.WPDIBLC + self.BIN_WL * self.PPDIBLC
self.PDIBLCB_i      = self.PDIBLCB + self.BIN_L * self.LPDIBLCB + self.BIN_W * self.WPDIBLCB + self.BIN_WL * self.PPDIBLCB
self.PSCBE1_i       = self.PSCBE1 + self.BIN_L * self.LPSCBE1 + self.BIN_W * self.WPSCBE1 + self.BIN_WL * self.PPSCBE1
self.PSCBE2_i       = self.PSCBE2 + self.BIN_L * self.LPSCBE2 + self.BIN_W * self.WPSCBE2 + self.BIN_WL * self.PPSCBE2
self.PDITS_i        = self.PDITS + self.BIN_L * self.LPDITS + self.BIN_W * self.WPDITS + self.BIN_WL * self.PPDITS
self.PDITSD_i       = self.PDITSD + self.BIN_L * self.LPDITSD + self.BIN_W * self.WPDITSD + self.BIN_WL * self.PPDITSD
self.FPROUT_i       = self.FPROUT + self.BIN_L * self.LFPROUT + self.BIN_W * self.WFPROUT + self.BIN_WL * self.PFPROUT
self.PVAG_i         = self.PVAG + self.BIN_L * self.LPVAG + self.BIN_W * self.WPVAG + self.BIN_WL * self.PPVAG
self.VSAT_i         = self.VSAT + self.BIN_L * self.LVSAT + self.BIN_W * self.WVSAT + self.BIN_WL * self.PVSAT
self.PSAT_i         = self.PSAT + self.BIN_L * self.LPSAT + self.BIN_W * self.WPSAT + self.BIN_WL * self.PPSAT
self.VSATCV_i       = self.VSATCV + self.BIN_L * self.LVSATCV + self.BIN_W * self.WVSATCV + self.BIN_WL * self.PVSATCV
self.CF_i           = self.CF + self.BIN_L * self.LCF + self.BIN_W * self.WCF + self.BIN_WL * self.PCF
self.CGSL_i         = self.CGSL + self.BIN_L * self.LCGSL + self.BIN_W * self.WCGSL + self.BIN_WL * self.PCGSL
self.CGDL_i         = self.CGDL + self.BIN_L * self.LCGDL + self.BIN_W * self.WCGDL + self.BIN_WL * self.PCGDL
self.CKAPPAS_i      = self.CKAPPAS + self.BIN_L * self.LCKAPPAS + self.BIN_W * self.WCKAPPAS + self.BIN_WL * self.PCKAPPAS
self.CKAPPAD_i      = self.CKAPPAD + self.BIN_L * self.LCKAPPAD + self.BIN_W * self.WCKAPPAD + self.BIN_WL * self.PCKAPPAD
self.ALPHA0_i       = self.ALPHA0 + self.BIN_L * self.LALPHA0 + self.BIN_W * self.WALPHA0 + self.BIN_WL * self.PALPHA0
self.BETA0_i        = self.BETA0 + self.BIN_L * self.LBETA0 + self.BIN_W * self.WBETA0 + self.BIN_WL * self.PBETA0
self.KVTH0WE_i      = self.KVTH0WE + self.BIN_L * self.LKVTH0WE  + self.BIN_W * self.WKVTH0WE + self.BIN_WL * self.PKVTH0WE
self.K2WE_i         = self.K2WE + self.BIN_L * self.LK2WE + self.BIN_W * self.WK2WE + self.BIN_WL * self.PK2WE
self.KU0WE_i        = self.KU0WE + self.BIN_L * self.LKU0WE + self.BIN_W * self.WKU0WE + self.BIN_WL * self.PKU0WE
self.AGIDL_i        = self.AGIDL + self.BIN_L * self.LAGIDL + self.BIN_W * self.WAGIDL + self.BIN_WL * self.PAGIDL
self.BGIDL_i        = self.BGIDL + self.BIN_L * self.LBGIDL + self.BIN_W * self.WBGIDL + self.BIN_WL * self.PBGIDL
self.CGIDL_i        = self.CGIDL + self.BIN_L * self.LCGIDL + self.BIN_W * self.WCGIDL + self.BIN_WL * self.PCGIDL
self.EGIDL_i        = self.EGIDL + self.BIN_L * self.LEGIDL + self.BIN_W * self.WEGIDL + self.BIN_WL * self.PEGIDL
self.AGISL_i        = self.AGISL + self.BIN_L * self.LAGISL + self.BIN_W * self.WAGISL + self.BIN_WL * self.PAGISL
self.BGISL_i        = self.BGISL + self.BIN_L * self.LBGISL + self.BIN_W * self.WBGISL + self.BIN_WL * self.PBGISL
self.CGISL_i        = self.CGISL + self.BIN_L * self.LCGISL + self.BIN_W * self.WCGISL + self.BIN_WL * self.PCGISL
self.EGISL_i        = self.EGISL + self.BIN_L * self.LEGISL + self.BIN_W * self.WEGISL + self.BIN_WL * self.PEGISL
self.UTE_i          = self.UTE + self.BIN_L * self.LUTE + self.BIN_W * self.WUTE + self.BIN_WL * self.PUTE
self.UA1_i          = self.UA1 + self.BIN_L * self.LUA1 + self.BIN_W * self.WUA1 + self.BIN_WL * self.PUA1
self.UC1_i          = self.UC1 + self.BIN_L * self.LUC1 + self.BIN_W * self.WUC1 + self.BIN_WL * self.PUC1
self.UD1_i          = self.UD1 + self.BIN_L * self.LUD1 + self.BIN_W * self.WUD1 + self.BIN_WL * self.PUD1
self.EU1_i          = self.EU1 + self.BIN_L * self.LEU1 + self.BIN_W * self.WEU1 + self.BIN_WL * self.PEU1
self.UCSTE_i        = self.UCSTE + self.BIN_L * self.LUCSTE + self.BIN_W * self.WUCSTE + self.BIN_WL * self.PUCSTE
self.PRT_i          = self.PRT + self.BIN_L * self.LPRT + self.BIN_W * self.WPRT + self.BIN_WL * self.PPRT
self.AT_i           = self.AT + self.BIN_L * self.LAT + self.BIN_W * self.WAT + self.BIN_WL * self.PAT
self.PTWGT_i        = self.PTWGT + self.BIN_L * self.LPTWGT + self.BIN_W * self.WPTWGT + self.BIN_WL * self.PPTWGT
self.IIT_i          = self.IIT + self.BIN_L * self.LIIT + self.BIN_W * self.WIIT + self.BIN_WL * self.PIIT
self.TGIDL_i        = self.TGIDL + self.BIN_L * self.LTGIDL + self.BIN_W * self.WTGIDL + self.BIN_WL * self.PTGIDL
self.IGT_i          = self.IGT + self.BIN_L * self.LIGT + self.BIN_W * self.WIGT + self.BIN_WL * self.PIGT
self.AIGBINV_i      = self.AIGBINV + self.BIN_L * self.LAIGBINV + self.BIN_W * self.WAIGBINV + self.BIN_WL * self.PAIGBINV
self.BIGBINV_i      = self.BIGBINV + self.BIN_L * self.LBIGBINV + self.BIN_W * self.WBIGBINV + self.BIN_WL * self.PBIGBINV
self.CIGBINV_i      = self.CIGBINV + self.BIN_L * self.LCIGBINV + self.BIN_W * self.WCIGBINV + self.BIN_WL * self.PCIGBINV
self.EIGBINV_i      = self.EIGBINV + self.BIN_L * self.LEIGBINV + self.BIN_W * self.WEIGBINV + self.BIN_WL * self.PEIGBINV
self.NIGBINV_i      = self.NIGBINV + self.BIN_L * self.LNIGBINV + self.BIN_W * self.WNIGBINV + self.BIN_WL * self.PNIGBINV
self.AIGBACC_i      = self.AIGBACC + self.BIN_L * self.LAIGBACC + self.BIN_W * self.WAIGBACC + self.BIN_WL * self.PAIGBACC
self.BIGBACC_i      = self.BIGBACC + self.BIN_L * self.LBIGBACC + self.BIN_W * self.WBIGBACC + self.BIN_WL * self.PBIGBACC
self.CIGBACC_i      = self.CIGBACC + self.BIN_L * self.LCIGBACC + self.BIN_W * self.WCIGBACC + self.BIN_WL * self.PCIGBACC
self.NIGBACC_i      = self.NIGBACC + self.BIN_L * self.LNIGBACC + self.BIN_W * self.WNIGBACC + self.BIN_WL * self.PNIGBACC
self.AIGC_i         = self.AIGC + self.BIN_L * self.LAIGC + self.BIN_W * self.WAIGC + self.BIN_WL * self.PAIGC
self.BIGC_i         = self.BIGC + self.BIN_L * self.LBIGC + self.BIN_W * self.WBIGC + self.BIN_WL * self.PBIGC
self.CIGC_i         = self.CIGC + self.BIN_L * self.LCIGC + self.BIN_W * self.WCIGC + self.BIN_WL * self.PCIGC
self.AIGS_i         = self.AIGS + self.BIN_L * self.LAIGS + self.BIN_W * self.WAIGS + self.BIN_WL * self.PAIGS
self.BIGS_i         = self.BIGS + self.BIN_L * self.LBIGS + self.BIN_W * self.WBIGS + self.BIN_WL * self.PBIGS
self.CIGS_i         = self.CIGS + self.BIN_L * self.LCIGS + self.BIN_W * self.WCIGS + self.BIN_WL * self.PCIGS
self.AIGD_i         = self.AIGD + self.BIN_L * self.LAIGD + self.BIN_W * self.WAIGD + self.BIN_WL * self.PAIGD
self.BIGD_i         = self.BIGD + self.BIN_L * self.LBIGD + self.BIN_W * self.WBIGD + self.BIN_WL * self.PBIGD
self.CIGD_i         = self.CIGD + self.BIN_L * self.LCIGD + self.BIN_W * self.WCIGD + self.BIN_WL * self.PCIGD
self.POXEDGE_i      = self.POXEDGE + self.BIN_L * self.LPOXEDGE + self.BIN_W * self.WPOXEDGE + self.BIN_WL * self.PPOXEDGE
self.DLCIG_i        = self.DLCIG + self.BIN_L * self.LDLCIG + self.BIN_W * self.WDLCIG + self.BIN_WL * self.PDLCIG
self.DLCIGD_i       = self.DLCIGD + self.BIN_L * self.LDLCIGD + self.BIN_W * self.WDLCIGD + self.BIN_WL * self.PDLCIGD
self.NTOX_i         = self.NTOX + self.BIN_L * self.LNTOX + self.BIN_W * self.WNTOX + self.BIN_WL * self.PNTOX
self.KT1_i          = self.KT1 + self.BIN_L * self.LKT1 + self.BIN_W * self.WKT1 + self.BIN_WL * self.PKT1
self.KT2_i          = self.KT2 + self.BIN_L * self.LKT2 + self.BIN_W * self.WKT2 + self.BIN_WL * self.PKT2
self.PSATB_i        = self.PSATB + self.BIN_L * self.LPSATB + self.BIN_W * self.WPSATB + self.BIN_WL * self.PPSATB
self.A1_i           = self.A1 + self.BIN_L * self.LA1 + self.BIN_W * self.WA1 + self.BIN_WL * self.PA1
self.A11_i          = self.A11 + self.BIN_L * self.LA11 + self.BIN_W * self.WA11 + self.BIN_WL * self.PA11
self.A2_i           = self.A2 + self.BIN_L * self.LA2 + self.BIN_W * self.WA2 + self.BIN_WL * self.PA2
self.A21_i          = self.A21 + self.BIN_L * self.LA21 + self.BIN_W * self.WA21 + self.BIN_WL * self.PA21
self.K0_i           = self.K0 + self.BIN_L * self.LK0 + self.BIN_W * self.WK0 + self.BIN_WL * self.PK0
self.M0_i           = self.M0 + self.BIN_L * self.LM0 + self.BIN_W * self.WM0 + self.BIN_WL * self.PM0
self.K01_i          = self.K01 + self.BIN_L * self.LK01 + self.BIN_W * self.WK01 + self.BIN_WL * self.PK01
self.M01_i          = self.M01 + self.BIN_L * self.LM01 + self.BIN_W * self.WM01 + self.BIN_WL * self.PM01
self.NFACTOREDGE_i  = self.NFACTOREDGE + self.BIN_L * self.LNFACTOREDGE + self.BIN_W * self.WNFACTOREDGE + self.BIN_WL * self.PNFACTOREDGE
self.NDEPEDGE_i     = self.NDEPEDGE + self.BIN_L * self.LNDEPEDGE + self.BIN_W * self.WNDEPEDGE + self.BIN_WL * self.PNDEPEDGE
self.CITEDGE_i      = self.CITEDGE + self.BIN_L * self.LCITEDGE + self.BIN_W * self.WCITEDGE + self.BIN_WL * self.PCITEDGE
self.CDSCDEDGE_i    = self.CDSCDEDGE + self.BIN_L * self.LCDSCDEDGE + self.BIN_W * self.WCDSCDEDGE + self.BIN_WL * self.PCDSCDEDGE
self.CDSCBEDGE_i    = self.CDSCBEDGE + self.BIN_L * self.LCDSCBEDGE + self.BIN_W * self.WCDSCBEDGE + self.BIN_WL * self.PCDSCBEDGE
self.ETA0EDGE_i     = self.ETA0EDGE + self.BIN_L * self.LETA0EDGE + self.BIN_W * self.WETA0EDGE + self.BIN_WL * self.PETA0EDGE
self.ETABEDGE_i     = self.ETABEDGE + self.BIN_L * self.LETABEDGE + self.BIN_W * self.WETABEDGE + self.BIN_WL * self.PETABEDGE
self.KT1EDGE_i      = self.KT1EDGE + self.BIN_L * self.LKT1EDGE + self.BIN_W * self.WKT1EDGE + self.BIN_WL * self.PKT1EDGE
self.KT1LEDGE_i     = self.KT1LEDGE + self.BIN_L * self.LKT1LEDGE + self.BIN_W * self.WKT1LEDGE + self.BIN_WL * self.PKT1LEDGE
self.KT2EDGE_i      = self.KT2EDGE + self.BIN_L * self.LKT2EDGE + self.BIN_W * self.WKT2EDGE + self.BIN_WL * self.PKT2EDGE
self.KT1EXPEDGE_i   = self.KT1EXPEDGE + self.BIN_L * self.LKT1EXPEDGE + self.BIN_W * self.WKT1EXPEDGE + self.BIN_WL * self.PKT1EXPEDGE
self.TNFACTOREDGE_i = self.TNFACTOREDGE + self.BIN_L * self.LTNFACTOREDGE + self.BIN_W * self.WTNFACTOREDGE + self.BIN_WL * self.PTNFACTOREDGE
self.TETA0EDGE_i    = self.TETA0EDGE + self.BIN_L * self.LTETA0EDGE + self.BIN_W * self.WTETA0EDGE + self.BIN_WL * self.PTETA0EDGE
self.K2EDGE_i       = self.K2EDGE + self.BIN_L * self.LK2EDGE + self.BIN_W * self.WK2EDGE + self.BIN_WL * self.PK2EDGE
self.KVTH0EDGE_i    = self.KVTH0EDGE + self.BIN_L * self.LKVTH0EDGE + self.BIN_W * self.WKVTH0EDGE + self.BIN_WL * self.PKVTH0EDGE
self.STK2EDGE_i     = self.STK2EDGE + self.BIN_L * self.LSTK2EDGE + self.BIN_W * self.WSTK2EDGE + self.BIN_WL * self.PSTK2EDGE
self.STETA0EDGE_i   = self.STETA0EDGE + self.BIN_L * self.LSTETA0EDGE + self.BIN_W * self.WSTETA0EDGE + self.BIN_WL * self.PSTETA0EDGE
self.C0_i           = self.C0 + self.BIN_L * self.LC0 + self.BIN_W * self.WC0 + self.BIN_WL * self.PC0
self.C01_i          = self.C01 + self.BIN_L * self.LC01 + self.BIN_W * self.WC01 + self.BIN_WL * self.PC01
self.C0SI_i         = self.C0SI + self.BIN_L * self.LC0SI + self.BIN_W * self.WC0SI + self.BIN_WL * self.PC0SI
self.C0SI1_i        = self.C0SI1 + self.BIN_L * self.LC0SI1 + self.BIN_W * self.WC0SI1 + self.BIN_WL * self.PC0SI1
self.C0SISAT_i      = self.C0SISAT + self.BIN_L * self.LC0SISAT + self.BIN_W * self.WC0SISAT + self.BIN_WL * self.PC0SISAT
self.C0SISAT1_i     = self.C0SISAT1 + self.BIN_L * self.LC0SISAT1 + self.BIN_W * self.WC0SISAT1 + self.BIN_WL * self.PC0SISAT1

if (self.ASYMMOD != 0):
    self.CDSCDR_i  = self.CDSCDR + self.BIN_L * self.LCDSCDR + self.BIN_W * self.WCDSCDR + self.BIN_WL * self.PCDSCDR
    self.ETA0R_i   = self.ETA0R + self.BIN_L * self.LETA0R + self.BIN_W * self.WETA0R + self.BIN_WL * self.PETA0R
    self.U0R_i     = self.U0R + self.BIN_L * self.LU0R + self.BIN_W * self.WU0R + self.BIN_WL * self.PU0R
    self.UAR_i     = self.UAR + self.BIN_L * self.LUAR + self.BIN_W * self.WUAR + self.BIN_WL * self.PUAR
    self.UDR_i     = self.UDR + self.BIN_L * self.LUDR + self.BIN_W * self.WUDR + self.BIN_WL * self.PUDR
    self.UCSR_i    = self.UCSR + self.BIN_L * self.LUCSR + self.BIN_W * self.WUCSR + self.BIN_WL * self.PUCSR
    self.UCR_i     = self.UCR + self.BIN_L * self.LUCR + self.BIN_W * self.WUCR + self.BIN_WL * self.PUCR
    self.PCLMR_i   = self.PCLMR + self.BIN_L * self.LPCLMR + self.BIN_W * self.WPCLMR + self.BIN_WL * self.PPCLMR
    self.PDIBLCR_i = self.PDIBLCR + self.BIN_L * self.LPDIBLCR + self.BIN_W * self.WPDIBLCR + self.BIN_WL * self.PPDIBLCR
    self.VSATR_i   = self.VSATR + self.BIN_L * self.LVSATR + self.BIN_W * self.WVSATR + self.BIN_WL * self.PVSATR
    self.PSATR_i   = self.PSATR + self.BIN_L * self.LPSATR + self.BIN_W * self.WPSATR + self.BIN_WL * self.PPSATR
    self.PTWGR_i   = self.PTWGR + self.BIN_L * self.LPTWGR + self.BIN_W * self.WPTWGR + self.BIN_WL * self.PPTWGR
else:
    self.CDSCDR_i  = 0.0
    self.ETA0R_i   = 0.0
    self.U0R_i     = 0.0
    self.UAR_i     = 0.0
    self.UDR_i     = 0.0
    self.UCSR_i    = 0.0
    self.UCR_i     = 0.0
    self.PCLMR_i   = 0.0
    self.PDIBLCR_i = 0.0
    self.VSATR_i   = 0.0
    self.PSATR_i   = 0.0
    self.PTWGR_i   = 0.0

# Geometrical scaling
self.T0        = self.NDEPL1 * max(self.Inv_L**self.NDEPLEXP1 - self.Inv_Llong**self.NDEPLEXP1, 0.0) + self.NDEPL2 * max(self.Inv_L**self.NDEPLEXP2 - self.Inv_Llong**self.NDEPLEXP2, 0.0)
self.T1        = self.NDEPW * max(self.Inv_W**self.NDEPWEXP - self.Inv_Wwide**self.NDEPWEXP, 0.0) + self.NDEPWL * (self.Inv_W * self.Inv_L)**self.NDEPWLEXP
self.NDEP_i    = self.NDEP_i * (1.0 + self.T0 + self.T1)
self.T0        = self.NFACTORL * max(self.Inv_L**self.NFACTORLEXP - self.Inv_Llong**self.NFACTORLEXP, 0.0)
self.T1        = self.NFACTORW * max(self.Inv_W**self.NFACTORWEXP - self.Inv_Wwide**self.NFACTORWEXP, 0.0) + self.NFACTORWL * self.Inv_WL**self.NFACTORWLEXP
self.NFACTOR_i = self.NFACTOR_i * (1.0 + self.T0 + self.T1)
self.T0        = (1.0 + self.CDSCDL * max(self.Inv_L**self.CDSCDLEXP - self.Inv_Llong**self.CDSCDLEXP, 0.0))
self.CDSCD_i   = self.CDSCD_i * self.T0
if (self.ASYMMOD != 0):
    self.CDSCDR_i = self.CDSCDR_i * self.T0
self.CDSCB_i = self.CDSCB_i * (1.0 + self.CDSCBL * max(self.Inv_L**self.CDSCBLEXP - self.Inv_Llong**self.CDSCBLEXP, 0.0))
self.U0_i    = self.MULU0 * self.U0_i
if (self.MOBSCALE != 1):
    if (self.U0LEXP > 0.0):
        self.U0_i = self.U0_i * (1.0 - self.U0L * max(self.Inv_L**self.U0LEXP - self.Inv_Llong**self.U0LEXP, 0.0))
        if (self.ASYMMOD != 0):
            self.U0R_i = self.U0R_i * (1.0 - self.U0L * max(self.Inv_L**self.U0LEXP - self.Inv_Llong**self.U0LEXP, 0.0))
    else:
        self.U0_i = self.U0_i * (1.0 - self.U0L)
        if (self.ASYMMOD != 0):
            self.U0R_i = self.U0R_i * (1.0 - self.U0L)
else:
    self.U0_i = self.U0_i * (1.0 - (self.UP1 * self.lexp(-self.Leff / self.LP1)) - (self.UP2 * self.lexp(-self.Leff / self.LP2)))
    if (self.ASYMMOD != 0):
        self.U0R_i = self.U0R_i * (1.0 - (self.UP1 * self.lexp(-self.Leff / self.LP1)) - (self.UP2 * self.lexp(-self.Leff / self.LP2)))
self.T0   = self.UAL * max(self.Inv_L**self.UALEXP - self.Inv_Llong**self.UALEXP, 0.0)
self.T1   = self.UAW * max(self.Inv_W**self.UAWEXP - self.Inv_Wwide**self.UAWEXP, 0.0) + self.UAWL * self.Inv_WL**self.UAWLEXP
self.UA_i = self.UA_i * (1.0 + self.T0 + self.T1)
if (self.ASYMMOD != 0):
    self.UAR_i = self.UAR_i * (1.0 + self.T0 + self.T1)
self.T0   = self.EUL * max(self.Inv_L**self.EULEXP - self.Inv_Llong**self.EULEXP, 0.0)
self.T1   = self.EUW * max(self.Inv_W**self.EUWEXP - self.Inv_Wwide**self.EUWEXP, 0.0) + self.EUWL * self.Inv_WL**self.EUWLEXP
self.EU_i = self.EU_i * (1.0 + self.T0 + self.T1)
self.T0   = 1.0 + self.UDL * max(self.Inv_L**self.UDLEXP - self.Inv_Llong**self.UDLEXP, 0.0)
self.UD_i = self.UD_i * self.T0
if (self.ASYMMOD != 0):
    self.UDR_i = self.UDR_i * self.T0
self.T0   = self.UCL * max(self.Inv_L**self.UCLEXP - self.Inv_Llong**self.UCLEXP, 0.0)
self.T1   = self.UCW * max(self.Inv_W**self.UCWEXP - self.Inv_Wwide**self.UCWEXP, 0.0) + self.UCWL * self.Inv_WL**self.UCWLEXP
self.UC_i = self.UC_i * (1.0 + self.T0 + self.T1)
if (self.ASYMMOD != 0):
    self.UCR_i = self.UCR_i * (1.0 + self.T0 + self.T1)
self.T0     = max(self.Inv_L**self.DSUB - self.Inv_Llong**self.DSUB, 0.0)
self.ETA0_i = self.ETA0_i * self.T0
if (self.ASYMMOD != 0):
    self.ETA0R_i = self.ETA0R_i * self.T0
self.ETAB_i   = self.ETAB_i * max(self.Inv_L**self.ETABEXP - self.Inv_Llong**self.ETABEXP, 0.0)
self.T0       = 1.0 + self.PDIBLCL * max(self.Inv_L**self.PDIBLCLEXP - self.Inv_Llong**self.PDIBLCLEXP, 0.0)
self.PDIBLC_i = self.PDIBLC_i * self.T0
if (self.ASYMMOD != 0):
    self.PDIBLCR_i = self.PDIBLCR_i * self.T0
self.T0       = self.DELTA_i * (1.0 + self.DELTAL * max(self.Inv_L**self.DELTALEXP - self.Inv_Llong**self.DELTALEXP, 0.0))
self.DELTA_i  = min(self.T0, 0.5)
self.FPROUT_i = self.FPROUT_i * (1.0 + self.FPROUTL * max(self.Inv_L**self.FPROUTLEXP - self.Inv_Llong**self.FPROUTLEXP, 0.0))
self.T0       = (1.0 + self.PCLML * max(self.Inv_L**self.PCLMLEXP - self.Inv_Llong**self.PCLMLEXP, 0.0))
self.PCLM_i   = self.PCLM_i * self.T0
self.PCLM_i   = max(self.PCLM_i, 0.0)
if (self.ASYMMOD != 0):
    self.PCLMR_i = self.PCLMR_i * self.T0
    self.PCLMR_i = max(self.PCLMR_i, 0.0)
self.T0     = self.VSATL * max(self.Inv_L**self.VSATLEXP - self.Inv_Llong**self.VSATLEXP, 0.0)
self.T1     = self.VSATW * max(self.Inv_W**self.VSATWEXP - self.Inv_Wwide**self.VSATWEXP, 0.0) + self.VSATWL * self.Inv_WL**self.VSATWLEXP
self.VSAT_i = self.VSAT_i * (1.0 + self.T0 + self.T1)
if (self.ASYMMOD != 0):
    self.VSATR_i = self.VSATR_i * (1.0 + self.T0 + self.T1)
self.PSAT_i = max(self.PSAT_i * (1.0 + self.PSATL * max(self.Inv_L**self.PSATLEXP - self.Inv_Llong**self.PSATLEXP, 0.0)), 0.25)
if (self.ASYMMOD != 0):
    self.PSATR_i = max(self.PSATR_i * (1.0 + self.PSATL * max(self.Inv_L**self.PSATLEXP - self.Inv_Llong**self.PSATLEXP, 0.0)), 0.25)
self.T0     = (1.0 + self.PTWGL * max(self.Inv_L**self.PTWGLEXP - self.Inv_Llong**self.PTWGLEXP, 0.0))
self.PTWG_i = self.PTWG_i * self.T0
if (self.ASYMMOD != 0):
    self.PTWGR_i = self.PTWGR_i * self.T0
self.ALPHA0_i = self.ALPHA0_i * (1.0 + self.ALPHA0L * max(self.Inv_L**self.ALPHA0LEXP - self.Inv_Llong**self.ALPHA0LEXP, 0.0))
self.AGIDL_i  = self.AGIDL_i * (1.0 + self.AGIDLL * self.Inv_L + self.AGIDLW * self.Inv_W)
self.AGISL_i  = self.AGISL_i * (1.0 + self.AGISLL * self.Inv_L + self.AGISLW * self.Inv_W)
self.AIGC_i   = self.AIGC_i * (1.0 + self.AIGCL * self.Inv_L + self.AIGCW * self.Inv_W)
self.AIGS_i   = self.AIGS_i * (1.0 + self.AIGSL * self.Inv_L + self.AIGSW * self.Inv_W)
self.AIGD_i   = self.AIGD_i * (1.0 + self.AIGDL * self.Inv_L + self.AIGDW * self.Inv_W)
self.PIGCD_i  = self.PIGCD * (1.0 + self.PIGCDL * self.Inv_L)
self.T0       = self.NDEPCVL1 * max(self.Inv_Lact**self.NDEPCVLEXP1 - self.Inv_Llong**self.NDEPCVLEXP1, 0.0) + self.NDEPCVL2 * max(self.Inv_Lact**self.NDEPCVLEXP2 - self.Inv_Llong**self.NDEPCVLEXP2, 0.0)
self.T1       = self.NDEPCVW * max(self.Inv_Wact**self.NDEPCVWEXP - self.Inv_Wwide**self.NDEPCVWEXP, 0.0) + self.NDEPCVWL * (self.Inv_Wact * self.Inv_Lact)**self.NDEPCVWLEXP
self.NDEPCV_i = self.NDEPCV_i * (1.0 + self.T0 + self.T1)
self.T0       = self.VFBCVL * max(self.Inv_Lact**self.VFBCVLEXP - self.Inv_Llong**self.VFBCVLEXP, 0.0)
self.T1       = self.VFBCVW * max(self.Inv_Wact**self.VFBCVWEXP - self.Inv_Wwide**self.VFBCVWEXP, 0.0) + self.VFBCVWL * self.Inv_WL**self.VFBCVWLEXP
self.VFBCV_i  = self.VFBCV_i * (1.0 + self.T0 + self.T1)
self.T0       = self.VSATCVL * max(self.Inv_Lact**self.VSATCVLEXP - self.Inv_Llong**self.VSATCVLEXP, 0.0)
self.T1       = self.VSATCVW * max(self.Inv_W**self.VSATCVWEXP - self.Inv_Wwide**self.VSATCVWEXP, 0.0) + self.VSATCVWL * self.Inv_WL**self.VSATCVWLEXP
self.VSATCV_i = self.VSATCV_i * (1.0 + self.T0 + self.T1)
self.PCLMCV_i = self.PCLMCV_i * (1.0 + self.PCLMCVL * max(self.Inv_Lact**self.PCLMCVLEXP - self.Inv_Llong**self.PCLMCVLEXP, 0.0))
self.PCLMCV_i = max(self.PCLMCV_i, 0.0)
self.T0       = self.K1L * max(self.Inv_L**self.K1LEXP - self.Inv_Llong**self.K1LEXP, 0.0)
self.T1       = self.K1W * max(self.Inv_W**self.K1WEXP - self.Inv_Wwide**self.K1WEXP, 0.0) + self.K1WL * self.Inv_WL**self.K1WLEXP
self.K1_i     = self.K1_i * (1.0 + self.T0 + self.T1)
self.T0       = self.K2L * max(self.Inv_L**self.K2LEXP - self.Inv_Llong**self.K2LEXP, 0.0)
self.T1       = self.K2W * max(self.Inv_W**self.K2WEXP - self.Inv_Wwide**self.K2WEXP, 0.0) + self.K2WL * self.Inv_WL**self.K2WLEXP
self.K2_i     = self.K2_i * (1.0 + self.T0 + self.T1)
self.PRWB_i   = self.PRWB_i * (1.0 + self.PRWBL * max(self.Inv_L**self.PRWBLEXP - self.Inv_Llong**self.PRWBLEXP, 0.0))

# Global scaling parameters for temperature
self.UTE_i   = self.UTE_i * (1.0 + self.Inv_L * self.UTEL)
self.UA1_i   = self.UA1_i * (1.0 + self.Inv_L * self.UA1L)
self.UD1_i   = self.UD1_i * (1.0 + self.Inv_L * self.UD1L)
self.AT_i    = self.AT_i * (1.0 + self.Inv_L * self.ATL)
self.PTWGT_i = self.PTWGT_i * (1.0 + self.Inv_L * self.PTWGTL)

if (self.RDSMOD == 1):
    self.RSW_i = self.RSW_i * (1.0 + self.RSWL * max(self.Inv_L**self.RSWLEXP - self.Inv_Llong**self.RSWLEXP, 0.0))
    self.RDW_i = self.RDW_i * (1.0 + self.RDWL * max(self.Inv_L**self.RDWLEXP - self.Inv_Llong**self.RDWLEXP, 0.0))
else:
    self.RDSW_i = self.RDSW_i * (1.0 + self.RDSWL * max(self.Inv_L**self.RDSWLEXP - self.Inv_Llong**self.RDSWLEXP, 0.0))

# Parameter checking
if (self.UCS_i < 1.0):
    self.UCS_i = 1.0
elif (self.UCS_i > 2.0):
    self.UCS_i = 2.0
if (self.ASYMMOD != 0):
    if (self.UCSR_i < 1.0):
        self.UCSR_i = 1.0
    elif (self.UCSR_i > 2.0):
        self.UCSR_i = 2.0
if (self.CGIDL_i < 0.0):
    print("Fatal: CGIDL_i = %e is negative.", CGIDL_i)
if (self.CGISL_i < 0.0):
    print("Fatal: CGISL_i = %e is negative.", CGISL_i)
if (self.CKAPPAD_i <= 0.0):
    print("Fatal: CKAPPAD_i = %e is non-positive.", CKAPPAD_i)
if (self.CKAPPAS_i <= 0.0):
    print("Fatal: CKAPPAS_i = %e is non-positive.", CKAPPAS_i)
if (self.PDITS_i < 0.0):
    print("Fatal: PDITS_i = %e is negative.", PDITS_i)
if (self.CIT_i < 0.0):
    print("Fatal: CIT_i = %e is negative.", CIT_i)
if (self.NFACTOR_i < 0.0):
    print("Fatal: NFACTOR_i = %e is negative.", NFACTOR_i)
if (self.K1_i < 0.0):
    print("Fatal: K1_i = %e is negative.", K1_i)
if (self.NSD_i <= 0.0):
    print("Fatal: NSD_i = %e is non-positive.", NSD_i)
if (self.NDEP_i <= 0.0):
    print("Fatal: NDEP_i = %e is non-positive.", NDEP_i)
if (self.NDEPCV_i <= 0.0):
    print("Fatal: NDEPCV_i = %e is non-positive.", NDEPCV_i)
if (self.IGBMOD != 0):
    if (self.NIGBINV_i <= 0.0):
        print("Fatal: NIGBINV_i = %e is non-positive.", NIGBINV_i)
    if (self.NIGBACC_i <= 0.0):
        print("Fatal: NIGBACC_i = %e is non-positive.", NIGBACC_i)
if (self.IGCMOD != 0):
    if (self.POXEDGE_i <= 0.0):
        print("Fatal: POXEDGE_i = %e is non-positive.", POXEDGE_i)
if (self.CDSCD_i < 0.0):
    print("Fatal: CDSCD_i = %e is negative.", CDSCD_i)
if (self.ASYMMOD != 0):
    if (self.CDSCDR_i < 0.0):
        print("Fatal: CDSCDR_i = %e is negative.", CDSCDR_i)
if (self.DLCIG_i < 0.0):
    print("Warning: DLCIG = %e is negative, setting it to 0.", DLCIG_i)
    self.DLCIG_i = 0.0
if (self.DLCIGD_i < 0.0):
    print("Warning: DLCIGD = %e is negative, setting it to 0.", DLCIGD_i)
    self.DLCIGD_i = 0.0
if (self.M0_i < 0.0):
    print("Warning: M0_i = %e is negative, setting it to 0.", M0_i)
    self.M0_i = 0.0
if (self.U0_i <= 0.0):
    print("Warning: U0_i = %e is non-positive, setting it to the default value.", U0_i)
    self.U0_i = 0.067
if (self.UA_i < 0.0):
    print("Warning: UA_i = %e is negative, setting it to 0.", UA_i)
    self.UA_i = 0.0
if (self.EU_i < 0.0):
    print("Warning: EU_i = %e is negative, setting it to 0.", EU_i)
    self.EU_i = 0.0
if (self.UD_i < 0.0):
    print("Warning: UD_i = %e is negative, setting it to 0.", UD_i)
    self.UD_i = 0.0
if (self.UCS_i < 0.0):
    print("Warning: UCS_i = %e is negative, setting it to 0.", UCS_i)
    self.UCS_i = 0.0

# Process drain series resistance
self.DMCGeff = self.DMCG - self.DMCGT
self.DMCIeff = self.DMCI
self.DMDGeff = self.DMDG - self.DMCGT

# Processing S/D resistances and conductances
if "NRS" in param.keys():
    self.RSourceGeo = self.RSH * self.NRS
elif (self.RGEOMOD > 0 and self.RSH > 0.0):
    self.RSourceGeo = self.BSIMBULKRdseffGeo(self.NF, self.GEOMOD, self.RGEOMOD, self.MINZ, self.Weff, self.RSH, self.DMCGeff, self.DMCIeff, self.DMDGeff, 1)
else:
    self.RSourceGeo = 0.0

if "NRD" in param.keys():
    self.RDrainGeo = self.RSH * self.NRD
elif (self.RGEOMOD > 0 and self.RSH > 0.0):
    self.RDrainGeo = self.BSIMBULKRdseffGeo(self.NF, self.GEOMOD, self.RGEOMOD, self.MINZ, self.Weff, self.RSH, self.DMCGeff, self.DMCIeff, self.DMDGeff, 0)
else:
    self.RDrainGeo = 0.0

# Clamping of S/D resistances
if (self.RDSMOD == 0):
    if (self.RSourceGeo < self.minr):
        self.RSourceGeo = 0.0
    if (self.RDrainGeo < self.minr):
        self.RDrainGeo = 0.0
else:
    if (self.RSourceGeo <= self.minr):
        self.RSourceGeo = self.minr
    if (self.RDrainGeo <= self.minr):
        self.RDrainGeo = self.minr
if (self.RDSMOD == 1):
    if (self.RSWMIN_i <= 0.0):
        self.RSWMIN_i = 0.0
    if (self.RDWMIN_i <= 0.0):
        self.RDWMIN_i = 0.0
    if (self.RSW_i <= 0.0):
        self.RSW_i = 0.0
    if (self.RDW_i <= 0.0):
        self.RDW_i = 0.0
else:
    if (self.RDSWMIN_i <= 0.0):
        self.RDSWMIN_i = 0.0
    if (self.RDSW_i <= 0.0):
        self.RDSW_i = 0.0

# Body resistance network
if (self.RBODYMOD != 0):
    self.Lnl  = self.lln(self.Leff * 1.0e6)
    self.Lnw  = self.lln(self.Weff * 1.0e6)
    self.Lnnf = self.lln(self.NF)
    self.Bodymode = 5
    self.Rbpb = self.RBPB
    self.Rbpd = self.RBPD
    self.Rbps = self.RBPS
    self.Rbdb = self.RBDB
    self.Rbsb = self.RBSB
    if ("RBPS0" not in param.keys()) or ("RBPD0" not in param.keys()):
        self.Bodymode = 1
    elif ("RBSBX0" not in param.keys()) and ("RBSBY0" not in param.keys()) or ("RBDBX0" not in param.keys()) and ("RBDBY0" not in param.keys()):
        self.Bodymode = 3
    if (self.RBODYMOD == 2):
        if (self.Bodymode == 5):
            self.Rbsbx = self.RBSBX0 * self.lexp(self.RBSDBXL * self.Lnl + self.RBSDBXW * self.Lnw + self.RBSDBXNF * self.Lnnf)
            self.Rbsby = self.RBSBY0 * self.lexp(self.RBSDBYL * self.Lnl + self.RBSDBYW * self.Lnw + self.RBSDBYNF * self.Lnnf)
            self.Rbsb  = self.Rbsbx * self.Rbsby / (self.Rbsbx + self.Rbsby)
            self.Rbdbx = self.RBDBX0 * self.lexp(self.RBSDBXL * self.Lnl + self.RBSDBXW * self.Lnw + self.RBSDBXNF * self.Lnnf)
            self.Rbdby = self.RBDBY0 * self.lexp(self.RBSDBYL * self.Lnl + self.RBSDBYW * self.Lnw + self.RBSDBYNF * self.Lnnf)
            self.Rbdb  = self.Rbdbx * self.Rbdby / (self.Rbdbx + self.Rbdby)
        if (self.Bodymode == 3 or self.Bodymode == 5):
            self.Rbps = self.RBPS0 * self.lexp(self.RBPSL * self.Lnl + self.RBPSW * self.Lnw + self.RBPSNF * self.Lnnf)
            self.Rbpd = self.RBPD0 * self.lexp(self.RBPDL * self.Lnl + self.RBPDW * self.Lnw + self.RBPDNF * self.Lnnf)
        self.Rbpbx = self.RBPBX0 * self.lexp(self.RBPBXL * self.Lnl + self.RBPBXW * self.Lnw + self.RBPBXNF * self.Lnnf)
        self.Rbpby = self.RBPBY0 * self.lexp(self.RBPBYL * self.Lnl + self.RBPBYW * self.Lnw + self.RBPBYNF * self.Lnnf)
        self.Rbpb  = self.Rbpbx * self.Rbpby / (self.Rbpbx + self.Rbpby)
    if (self.RBODYMOD == 1 or (self.RBODYMOD == 2 and self.Bodymode == 5)):
        if (self.Rbdb < 1.0e-3):
            Grbdb = 1.0e3  # in mho
        else:
            self.Grbdb = self.GBMIN + 1.0 / self.Rbdb
        if (self.Rbpb < 1.0e-3):
            self.Grbpb = 1.0e3
        else:
            self.Grbpb = self.GBMIN + 1.0 / self.Rbpb
        if (self.Rbps < 1.0e-3):
            self.Grbps = 1.0e3
        else:
            self.Grbps = self.GBMIN + 1.0 / self.Rbps
        if (self.Rbsb < 1.0e-3):
            self.Grbsb = 1.0e3
        else:
            self.Grbsb = self.GBMIN + 1.0 / self.Rbsb
        if (self.Rbpd < 1.0e-3):
            self.Grbpd = 1.0e3
        else:
            self.Grbpd = self.GBMIN + 1.0 / self.Rbpd
    elif (self.RBODYMOD == 2 and self.Bodymode == 3):
        self.Grbdb = self.GBMIN
        self.Grbsb = self.GBMIN
        if (self.Rbpb < 1.0e-3):
            self.Grbpb = 1.0e3
        else:
            self.Grbpb = self.GBMIN + 1.0 / self.Rbpb
        if (self.Rbps < 1.0e-3):
            self.Grbps = 1.0e3
        else:
            self.Grbps = self.GBMIN + 1.0 / self.Rbps
        if (self.Rbpd < 1.0e-3):
            self.Grbpd = 1.0e3
        else:
            self.Grbpd = self.GBMIN + 1.0 / self.Rbpd
    elif (self.RBODYMOD == 2 and self.Bodymode == 1):
        self.Grbdb = self.GBMIN
        self.Grbsb = self.GBMIN
        self.Grbps = 1.0e3
        self.Grbpd = 1.0e3
        if (self.Rbpb < 1.0e-3):
            self.Grbpb = 1.0e3
        else:
            self.Grbpb = self.GBMIN + 1.0 / self.Rbpb

# Gate process resistance
self.Grgeltd = self.RSHG * (self.XGW + self.Weffcj / 3.0 / self.NGCON) / (self.NGCON * self.NF * (self.Lnew - self.XGL))
if (self.Grgeltd > 0.0):
    self.Grgeltd = 1.0 / self.Grgeltd
else:
    self.Grgeltd = 1.0e3
    if (self.RGATEMOD != 0):
        print("Warning: (instance %M) The gate conductance reset to 1.0e3 mho.")

self.T0           = self.TOXE * self.TOXE
self.T1           = self.TOXE * self.POXEDGE_i
self.T2           = self.T1 * self.T1
self.ToxRatio     = self.lexp(self.NTOX_i * self.lln(self.TOXREF / self.TOXE)) / self.T0
self.ToxRatioEdge = self.lexp(self.NTOX_i * self.lln(self.TOXREF / self.T1)) / self.T2
self.Aechvb       = 4.97232e-7 if (self.TYPE == self.ntype) else 3.42537e-7
self.Bechvb       = 7.45669e11 if (self.TYPE == self.ntype) else 1.16645e12
self.AechvbEdge   = self.Aechvb * self.Weff * self.ToxRatioEdge
self.BechvbEdge   = -self.Bechvb * self.TOXE * self.POXEDGE_i
self.Aechvb       = self.Aechvb * (self.Weff * self.Leff * self.ToxRatio)
self.Bechvb       = -self.Bechvb * self.TOXE
self.Weff_SH      = self.WTH0 + self.Weff

# Parameters for self-heating effects
if (self.SHMOD != 0) and (self.RTH0 > 0.0) and (self.Weff_SH > 0.0):
    self.gth = self.Weff_SH * self.NF / self.RTH0
    self.cth = self.CTH0 * self.Weff_SH * self.NF
else:
    # Set gth to some value to prevent a singular G matrix
    self.gth = 1.0
    self.cth = 0.0

# Temperature-dependent calculations
if (self.TNOM <= -self.P_CELSIUS0):
    self.T0 = self.REFTEMP - self.P_CELSIUS0
    print("Warning: TNOM = %e C <= %e C. Setting TNOM to %e C.", TNOM, -P_CELSIUS0, T0)
    self.Tnom = self.REFTEMP
else:
    self.Tnom = self.TNOM + self.P_CELSIUS0
self.DevTemp = self.TEMP + self.P_CELSIUS0 + self.DTEMP

self.Vt         = self.KboQ * self.DevTemp
self.inv_Vt     = 1.0 / self.Vt
self.TRatio     = self.DevTemp / self.Tnom
self.delTemp    = self.DevTemp - self.Tnom
self.Vtm        = self.KboQ * self.DevTemp
self.Vtm0       = self.KboQ * self.Tnom
self.Eg         = self.BG0SUB - self.TBGASUB * self.DevTemp * self.DevTemp / (self.DevTemp + self.TBGBSUB)
self.Eg0        = self.BG0SUB - self.TBGASUB * self.Tnom * self.Tnom / (self.Tnom + self.TBGBSUB)
self.T1         = (self.DevTemp / self.Tnom) * sqrt(self.DevTemp / self.Tnom)
self.ni         = self.NI0SUB * self.T1 * self.lexp(self.Eg / (2.0 * self.Vtm0) - self.Eg / (2.0 * self.Vtm))
if ((self.SHMOD != 0) and (self.RTH0 > 0.0) and (self.Weff_SH > 0.0)):
    self.T0   = self.lln(self.NDEP_i / self.ni)
    self.phib = sqrt(self.T0 * self.T0 + 1.0e-6)
else:
    self.phib = self.lln(self.NDEP_i / self.ni)
if ((self.SHMOD != 0) and (self.RTH0 > 0.0) and (self.Weff_SH > 0.0)):
    self.T0  = self.lln(self.NDEPEDGE_i * self.NSD_i / (self.ni * self.ni))
    self.Vbi_edge = sqrt(self.T0 * self.T0 + 1.0e-6)
else:
    self.Vbi_edge = self.lln(self.NDEPEDGE_i * self.NSD_i / (self.ni * self.ni))
if (self.NGATE_i > 0.0):
    self.Vfbsdr = -self.devsign * self.Vt * self.lln(self.NGATE_i / self.NSD_i) + self.VFBSDOFF
else:
    self.Vfbsdr = 0.0

# Short channel effects
self.Phist     = max(0.4 + self.Vt * self.phib + self.PHIN_i, 0.4)
self.sqrtPhist = sqrt(self.Phist)
self.T1DEP     = sqrt(2.0 * self.epssi / (self.q * self.NDEP_i))
self.litl      = sqrt((self.epssi / self.epsox) * self.TOXE * self.XJ_i)
self.NFACTOR_t = self.NFACTOR_i * self.hypsmooth((1.0 + self.TNFACTOR * (self.TRatio - 1.0)), 1e-3)
self.ETA0_t    = self.ETA0_i * (1.0 + self.TETA0 * (self.TRatio - 1.0))
if (self.ASYMMOD != 0):
    self.ETA0R_t = self.ETA0R_i * (1.0 + self.TETA0 * (self.TRatio - 1.0))

# Mobility degradation
self.eta_mu = (self.Oneby3 * self.ETAMOB) if (self.TYPE != self.ntype) else (0.5 * self.ETAMOB)
self.U0_t   = self.U0_i * self.TRatio**self.UTE_i
self.UA_t   = self.UA_i * self.hypsmooth(1.0 + self.UA1_i * self.delTemp - 1.0e-6, 1.0e-3)
self.UC_t   = self.UC_i * self.hypsmooth(1.0 + self.UC1_i * self.delTemp - 1.0e-6, 1.0e-3)
self.UD_t   = self.UD_i * self.TRatio**self.UD1_i
self.UCS_t  = self.UCS_i * self.TRatio**self.UCSTE_i
self.EU_t   = self.EU_i * self.hypsmooth((1.0 + self.EU1_i * (self.TRatio - 1.0)), 1e-3)
if (self.ASYMMOD != 0):
    self.U0R_t  = self.U0R_i * self.TRatio**self.UTE_i
    self.UAR_t  = self.UAR_i * self.hypsmooth(1.0 + self.UA1_i * self.delTemp - 1.0e-6, 1.0e-3)
    self.UCR_t  = self.UCR_i * self.hypsmooth(1.0 + self.UC1_i * self.delTemp - 1.0e-6, 1.0e-3)
    self.UDR_t  = self.UDR_i * self.TRatio**self.UD1_i
    self.UCSR_t = self.UCSR_i * self.TRatio**self.UCSTE_i
else:
    self.U0R_t  = 0.0
    self.UAR_t  = 0.0
    self.UCR_t  = 0.0
    self.UDR_t  = 0.0
    self.UCSR_t = 0.0
self.rdstemp = self.TRatio**self.PRT_i
self.VSAT_t  = self.VSAT_i * self.TRatio**-self.AT_i
if (self.VSAT_t < 100.0):
    print("Warning: VSAT(%f) = %e is less than 100, setting it to 100.", DevTemp, VSAT_t)
    self.VSAT_t = 100.0
if (self.HVMOD == 1):
    self.rdstemphv = self.TRatio**self.PRTHV
    self.VDRIFT_t  = self.VDRIFT * self.TRatio**-self.ATHV
if (self.ASYMMOD != 0):
    self.VSATR_t = self.VSATR_i * self.TRatio**-self.AT_i
    if(self.VSATR_t < 100.0):
        print("Warning: VSATR(%f) = %e is less than 100, setting it to 100.", DevTemp, VSATR_t)
        self.VSATR_t = 100.0

self.VSATCV_t = self.VSATCV_i * self.TRatio**-self.AT_i
if (self.VSATCV_t < 100.0):
    print("Warning: VSATCV(%f) = %e is less than 100, setting it to 100.", DevTemp, VSATCV_t)
    self.VSATCV_t = 100.0
self.DELTA_t = 1.0 / ( self.hypsmooth((1.0 / self.DELTA_i) * (1.0 + self.TDELTA * self.delTemp) - 2.0 , 1.0e-3) + 2.0)
self.PTWG_t  = self.PTWG_i * self.hypsmooth(1.0 - self.PTWGT_i * self.delTemp - 1.0e-6, 1.0e-3)
if (self.ASYMMOD != 0):
    self.PTWGR_t = self.PTWGR_i * self.hypsmooth(1.0 - self.PTWGT_i * self.delTemp - 1.0e-6, 1.0e-3)
self.A1_t    = self.A1_i * self.hypsmooth(1.0 + self.A11_i * self.delTemp - 1.0e-6, 1.0e-3)
self.A2_t    = self.A2_i * self.hypsmooth(1.0 + self.A21_i * self.delTemp - 1.0e-6, 1.0e-3)
self.BETA0_t = self.BETA0_i * self.TRatio**self.IIT_i
self.BGIDL_t = self.BGIDL_i * self.hypsmooth(1.0 + self.TGIDL_i * self.delTemp - 1.0e-6, 1.0e-3)
self.BGISL_t = self.BGISL_i * self.hypsmooth(1.0 + self.TGIDL_i * self.delTemp - 1.0e-6, 1.0e-3)
self.igtemp  = self.lexp(self.IGT_i * self.lln(self.TRatio))
self.K0_t    = self.K0_i * self.hypsmooth(1.0 + self.K01_i * self.delTemp - 1.0e-6, 1.0e-3)
self.M0_t    = self.M0_i * self.hypsmooth(1.0 + self.M01_i * self.delTemp - 1.0e-6, 1.0e-3)
self.C0_t    = self.C0_i * self.hypsmooth(1.0 + self.C01_i * self.delTemp - 1.0e-6, 1.0e-3)
self.C0SI_t  = self.C0SI_i * self.hypsmooth(1.0 + self.C0SI1_i * self.delTemp - 1.0e-6, 1.0e-3)
self.C0SISAT_t = self.C0SISAT_i * self.hypsmooth(1.0 + self.C0SISAT1_i * self.delTemp - 1.0e-6, 1.0e-3)

# Diode model temperature effects
self.CJS_t     = self.CJS * self.hypsmooth(1.0 + self.TCJ * self.delTemp - 1.0e-6, 1.0e-3)
self.CJD_t     = self.CJD * self.hypsmooth(1.0 + self.TCJ * self.delTemp - 1.0e-6, 1.0e-3)
self.CJSWS_t   = self.CJSWS * self.hypsmooth(1.0 + self.TCJSW * self.delTemp - 1.0e-6, 1.0e-3)
self.CJSWD_t   = self.CJSWD * self.hypsmooth(1.0 + self.TCJSW * self.delTemp - 1.0e-6, 1.0e-3)
self.CJSWGS_t  = self.CJSWGS * self.hypsmooth(1.0 + self.TCJSWG * self.delTemp - 1.0e-6, 1.0e-3)
self.CJSWGD_t  = self.CJSWGD * self.hypsmooth(1.0 + self.TCJSWG * self.delTemp - 1.0e-6, 1.0e-3)
self.PBS_t     = self.hypsmooth(self.PBS - self.TPB * self.delTemp - 0.01, 1.0e-3) + 0.01
self.PBD_t     = self.hypsmooth(self.PBD - self.TPB * self.delTemp - 0.01, 1.0e-3) + 0.01
self.PBSWS_t   = self.hypsmooth(self.PBSWS - self.TPBSW * self.delTemp - 0.01, 1.0e-3) + 0.01
self.PBSWD_t   = self.hypsmooth(self.PBSWD - self.TPBSW * self.delTemp - 0.01, 1.0e-3) + 0.01
self.PBSWGS_t  = self.hypsmooth(self.PBSWGS - self.TPBSWG * self.delTemp - 0.01, 1.0e-3) + 0.01
self.PBSWGD_t  = self.hypsmooth(self.PBSWGD - self.TPBSWG * self.delTemp - 0.01, 1.0e-3) + 0.01
self.T0        = self.Eg0 / self.Vtm0 - self.Eg / self.Vtm
self.T1        = self.lln(self.TRatio)
self.T3        = self.lexp((self.T0 + self.XTIS * self.T1) / self.NJS)
self.JSS_t     = self.JSS * self.T3
self.JSWS_t    = self.JSWS * self.T3
self.JSWGS_t   = self.JSWGS * self.T3
self.T3        = self.lexp((self.T0 + self.XTID * self.T1) / self.NJD)
self.JSD_t     = self.JSD * self.T3
self.JSWD_t    = self.JSWD * self.T3
self.JSWGD_t   = self.JSWGD * self.T3
self.JTSS_t    = self.JTSS * self.lexp(self.Eg0 * self.XTSS * (self.TRatio - 1.0) / self.Vtm)
self.JTSSWS_t  = self.JTSSWS * self.lexp(self.Eg0 * self.XTSSWS * (self.TRatio - 1.0) / self.Vtm)
self.JTSSWGS_t = self.JTSSWGS * (sqrt(self.JTWEFF / self.Weffcj) + 1.0) * self.lexp(self.Eg0 * self.XTSSWGS * (self.TRatio - 1) / self.Vtm)
self.JTSD_t    = self.JTSD * self.lexp(self.Eg0 * self.XTSD * (self.TRatio - 1.0) / self.Vtm)
self.JTSSWD_t  = self.JTSSWD * self.lexp(self.Eg0 * self.XTSSWD * (self.TRatio - 1.0) / self.Vtm)
self.JTSSWGD_t = self.JTSSWGD * (sqrt(self.JTWEFF / self.Weffcj) + 1.0) * self.lexp(self.Eg0 * self.XTSSWGD * (self.TRatio - 1) / self.Vtm)

# All NJT*'s smoothed to 0.01 to prevent divide by zero/negative values
self.NJTS_t     = self.hypsmooth(self.NJTS * (1.0 + self.TNJTS * (self.TRatio - 1.0)) - 0.01, 1.0e-3) + 0.01
self.NJTSSW_t   = self.hypsmooth(self.NJTSSW * (1.0 + self.TNJTSSW * (self.TRatio - 1.0)) - 0.01, 1.0e-3) + 0.01
self.NJTSSWG_t  = self.hypsmooth(self.NJTSSWG * (1.0 + self.TNJTSSWG * (self.TRatio - 1.0)) - 0.01, 1.0e-3) + 0.01
self.NJTSD_t    = self.hypsmooth(self.NJTSD * (1.0 + self.TNJTSD * (self.TRatio - 1.0)) - 0.01, 1.0e-3) + 0.01
self.NJTSSWD_t  = self.hypsmooth(self.NJTSSWD * (1.0 + self.TNJTSSWD * (self.TRatio - 1.0)) - 0.01, 1.0e-3) + 0.01
self.NJTSSWGD_t = self.hypsmooth(self.NJTSSWGD * (1.0 + self.TNJTSSWGD * (self.TRatio - 1.0)) - 0.01, 1.0e-3) + 0.01

# Effective S/D junction area and perimeters
self.temp_PSeff, self.temp_PDeff, self.temp_ASeff, self.temp_ADeff = self.BSIMBULKPAeffGeo(self.NF, self.GEOMOD, self.MINZ, self.Weffcj, self.DMCGeff, self.DMCIeff, self.DMDGeff)
if "AS" in param.keys():
    self.ASeff = self.AS * self.WMLT * self.LMLT
else:
    self.ASeff = self.temp_ASeff
if (self.ASeff < 0.0):
    print("Warning: (instance %M) ASeff = %e is negative. Set to 0.0.", ASeff)
    self.ASeff = 0.0
if "AD" in param.keys():
    self.ADeff = self.AD * self.WMLT * self.LMLT
else:
    self.ADeff = self.temp_ADeff
if (self.ADeff < 0.0):
    print("Warning: (instance %M) ADeff = %e is negative. Set to 0.0.", ADeff)
    self.ADeff = 0.0
if "PS" in param.keys():
    if (self.PERMOD == 0):
        # PS does not include gate-edge perimeters
        self.PSeff = self.PS * self.WMLT
    else:
        # PS includes gate-edge perimeters
        self.PSeff = max(self.PS * self.WMLT - self.Weffcj * self.NF, 0.0)
else:
    self.PSeff = self.temp_PSeff
    if (self.PSeff < 0.0):
        print("Warning: (instance %M) PSeff = %e is negative. Set to 0.0.", PSeff)
        self.PSeff = 0.0
if "PD" in param.keys():
    if (self.PERMOD == 0):
        # PD does not include gate-edge perimeters
        self.PDeff = self.PD * self.WMLT
    else:
        # PD includes gate-edge perimeters
        self.PDeff = max(self.PD * self.WMLT - self.Weffcj * self.NF, 0.0)
else:
    self.PDeff = self.temp_PDeff
    if (self.PDeff < 0.0):
        print("Warning: (instance %M) PDeff = %e is negative. Set to 0.0.", PDeff)
        self.PDeff = 0.0

self.Isbs = self.ASeff * self.JSS_t + self.PSeff * self.JSWS_t + self.Weffcj * self.NF * self.JSWGS_t
if (self.Isbs > 0.0):
    self.Nvtms    = self.Vtm * self.NJS
    self.XExpBVS  = self.lexp(-self.BVS / self.Nvtms) * self.XJBVS
    self.T2       = max(self.IJTHSFWD / self.Isbs, 10.0)
    self.Tb       = 1.0 + self.T2 - self.XExpBVS
    self.VjsmFwd  = self.Nvtms * self.lln(0.5 * (self.Tb + sqrt(self.Tb * self.Tb + 4.0 * self.XExpBVS)))
    self.T0       = self.lexp(self.VjsmFwd / self.Nvtms)
    self.IVjsmFwd = self.Isbs * (self.T0 - self.XExpBVS / self.T0 + self.XExpBVS - 1.0)
    self.SslpFwd  = self.Isbs * (self.T0 + self.XExpBVS / self.T0) / self.Nvtms
    self.T2       = self.hypsmooth(self.IJTHSREV / self.Isbs - 10.0, 1.0e-3) + 10.0
    self.VjsmRev  = -self.BVS - self.Nvtms * self.lln((self.T2 - 1.0) / self.XJBVS)
    self.T1       = self.XJBVS * self.lexp(-(self.BVS + self.VjsmRev) / self.Nvtms)
    self.IVjsmRev = self.Isbs * (1.0 + self.T1)
    self.SslpRev  = -self.Isbs * self.T1 / self.Nvtms
else:
    self.Nvtms    = 0.0
    self.XExpBVS  = 0.0
    self.VjsmFwd  = 0.0
    self.IVjsmFwd = 0.0
    self.SslpFwd  = 0.0
    self.VjsmRev  = 0.0
    self.IVjsmRev = 0.0
    self.SslpRev  = 0.0

# Drain-side junction currents
self.Isbd = self.ADeff * self.JSD_t + self.PDeff * self.JSWD_t + self.Weffcj * self.NF * self.JSWGD_t
if (self.Isbd > 0.0):
    self.Nvtmd    = self.Vtm * self.NJD
    self.XExpBVD  = self.lexp(-self.BVD / self.Nvtmd) * self.XJBVD
    self.T2       = max(self.IJTHDFWD / self.Isbd, 10.0)
    self.Tb       = 1.0 + self.T2 - self.XExpBVD
    self.VjdmFwd  = self.Nvtmd * self.lln(0.5 * (self.Tb + sqrt(self.Tb * self.Tb + 4.0 * self.XExpBVD)))
    self.T0       = self.lexp(self.VjdmFwd / self.Nvtmd)
    self.IVjdmFwd = self.Isbd * (self.T0 - self.XExpBVD / self.T0 + self.XExpBVD - 1.0)
    self.DslpFwd  = self.Isbd * (self.T0 + self.XExpBVD / self.T0) / self.Nvtmd
    self.T2       = self.hypsmooth(self.IJTHDREV / self.Isbd - 10.0, 1.0e-3) + 10.0
    self.VjdmRev  = -self.BVD - self.Nvtmd * self.lln((self.T2 - 1.0) / self.XJBVD)
    self.T1       = self.XJBVD * self.lexp(-(self.BVD + self.VjdmRev) / self.Nvtmd)
    self.IVjdmRev = self.Isbd * (1.0 + self.T1)
    self.DslpRev  = -self.Isbd * self.T1 / self.Nvtmd
else:
    self.Nvtmd    = 0.0
    self.XExpBVD  = 0.0
    self.VjdmFwd  = 0.0
    self.IVjdmFwd = 0.0
    self.DslpFwd  = 0.0
    self.VjdmRev  = 0.0
    self.IVjdmRev = 0.0
    self.DslpRev  = 0.0

# STI stress equations
if ((self.SA > 0.0) and (self.SB > 0.0) and ((self.NF == 1.0) or ((self.NF > 1.0) and (self.SD > 0.0)))):
    self.T0              = self.Lnew**self.LLODKU0
    self.W_tmp_stress    = self.Wnew + self.WLOD
    self.T1              = self.W_tmp_stress**self.WLODKU0
    self.tmp1_stress     = self.LKU0 / self.T0 + self.WKU0 / self.T1 + self.PKU0 / (self.T0 * self.T1)
    self.kstress_u0      = 1.0 + self.tmp1_stress
    self.T0              = self.Lnew**self.LLODVTH
    self.T1              = self.W_tmp_stress**self.WLODVTH
    self.tmp1_stress_vth = self.LKVTH0 / self.T0 + self.WKVTH0 / self.T1 + self.PKVTH0 / (self.T0 * self.T1)
    self.kstress_vth0    = 1.0 + self.tmp1_stress_vth
    self.T0              = self.TRatio - 1.0
    self.ku0_temp        = self.kstress_u0 * (1.0 + self.TKU0 * self.T0) + 1.0e-9
    for i in range(self.NF):
        self.T0     = 1.0 / self.NF / (self.SA + 0.5 * self.L_mult + i * (self.SD + self.L_mult))
        self.T1     = 1.0 / self.NF / (self.SB + 0.5 * self.L_mult + i * (self.SD + self.L_mult))
        self.Inv_sa = self.Inv_sa + self.T0
        self.Inv_sb = self.Inv_sb + self.T1
    self.Inv_saref   = 1.0 / (self.SAREF + 0.5 * self.L_mult)
    self.Inv_sbref   = 1.0 / (self.SBREF + 0.5 * self.L_mult)
    self.Inv_odref   = self.Inv_saref + self.Inv_sbref
    self.rho_ref     = (self.KU0 / self.ku0_temp) * self.Inv_odref
    self.Inv_od      = self.Inv_sa + self.Inv_sb
    self.rho         = (self.KU0 / self.ku0_temp) * self.Inv_od
    self.mu0_mult    = (1.0 + self.rho) / (1.0 + self.rho_ref)
    self.vsat_mult   = (1.0 + self.rho * self.KVSAT) / (1.0 + self.rho_ref * self.KVSAT)
    self.vth0_stress = (self.KVTH0 / self.kstress_vth0) * (self.Inv_od - self.Inv_odref)
    self.k2_stress   = (self.STK2 / self.kstress_vth0**self.LODK2) * (self.Inv_od - self.Inv_odref)
    self.eta_stress  = (self.STETA0 / self.kstress_vth0**self.LODETA0) * (self.Inv_od - self.Inv_odref)
    self.U0_t        = self.U0_t * self.mu0_mult
    self.VSAT_t      = self.VSAT_t * self.vsat_mult
    self.K2_i        = self.K2_i + self.k2_stress
    self.ETA0_t      = self.ETA0_t + self.eta_stress
    if (self.EDGEFET == 1):
        self.vth0_stress_EDGE = (self.KVTH0EDGE_i / self.kstress_vth0) * (self.Inv_od - self.Inv_odref)
        self.k2_stress_EDGE   = (self.STK2EDGE_i / self.kstress_vth0**self.LODK2) * (self.Inv_od - self.Inv_odref)
        self.eta_stress_EDGE  = (self.STETA0EDGE_i / self.kstress_vth0**self.LODETA0) * (self.Inv_od - self.Inv_odref)
    self.K2EDGE_i   = self.K2EDGE_i + self.k2_stress_EDGE
    self.ETA0EDGE_i = self.ETA0EDGE_i + self.eta_stress_EDGE
else:
    self.vth0_stress = 0.0
    self.vth0_stress_EDGE = 0.0

# Well proximity effect
if (self.WPEMOD == 1):
    self.Wdrn      = self.W / self.NF
    self.local_sca = self.SCA
    self.local_scb = self.SCB
    self.local_scc = self.SCC
    if ("SCA" not in param.keys()) and ("SCB" not in param.keys()) and ("SCC" not in param.keys()):
        if ("SC" in param.keys()) and (self.SC > 0.0):
            self.T1        = self.SC + self.Wdrn
            self.T2        = 1.0 / self.SCREF
            self.local_sca = self.SCREF * self.SCREF / (self.SC * self.T1)
            self.local_scb = ((0.1 * self.SC + 0.01 * self.SCREF) * self.lexp(-10.0 * self.SC * self.T2)  - (0.1 * self.T1 + 0.01 * self.SCREF) * self.lexp(-10.0 * self.T1 * self.T2)) / self.Wdrn
            self.local_scc = ((0.05 * self.SC + 0.0025 * self.SCREF) * self.lexp(-20.0 * self.SC * self.T2)  - (0.05 * self.T1 + 0.0025 * self.SCREF) * self.lexp(-20.0 * self.T1 * self.T2)) / self.Wdrn
        else:
            print("Warning: (Instance %M) No WPE as none of SCA, SCB, SCC, SC is given and/or SC not positive.")
else:
    self.local_sca = 0.0
    self.local_scb = 0.0
    self.local_scc = 0.0

self.vth0_well = self.KVTH0WE_i * (self.local_sca + self.WEB * self.local_scb + self.WEC * self.local_scc)
self.k2_well   = self.K2WE_i * (self.local_sca + self.WEB * self.local_scb + self.WEC * self.local_scc)
self.mu_well   = 1.0 + self.KU0WE_i * (self.local_sca + self.WEB * self.local_scb + self.WEC * self.local_scc)
self.U0_t      = self.U0_t * self.mu_well
self.K2_i      = self.K2_i + self.k2_well

# Load terminal voltages
self.Vg            = self.devsign * (self.VG - self.VB)
self.Vd            = self.devsign * (self.VD - self.VB)
self.Vs            = self.devsign * (self.VS - self.VB)
self.Vds           = self.Vd - self.Vs
self.Vds_noswap    = self.Vds
self.Vsb_noswap    = self.Vs
self.Vdb_noswap    = self.Vd
self.Vbs_jct       = self.devsign * (self.VB - self.VS)
self.Vbd_jct       = self.devsign * (self.VB - self.VD)
self.Vgd_noswap    = self.Vg - self.Vd
self.Vgs_noswap    = self.Vg - self.Vs
self.Vgd_ov_noswap = self.devsign * (self.VG - self.VD)
self.Vgs_ov_noswap = self.devsign * (self.VG - self.VS)

# Terminal voltage conditioning
# Source-drain interchange
self.sigvds = 1.0
if (self.Vds < 0.0):
    self.sigvds = -1.0
    self.Vd = self.devsign * (self.VS - self.VB)
    self.Vs = self.devsign * (self.VD - self.VB)
self.Vds  = self.Vd - self.Vs
self.T0   = self.AVDSX * self.Vds
if (self.T0 > self.EXPL_THRESHOLD):
   self.T1 = self.T0
else:
   self.T1 = log(1.0 + exp(self.T0))
self.Vdsx = ((2.0 / self.AVDSX) * self.T1) - self.Vds - ((2.0 / self.AVDSX) * log(2.0))
self.Vbsx = -(self.Vs + 0.5 * (self.Vds - self.Vdsx))

# Asymmetry model
self.T0 = tanh(0.6 * self.Vds_noswap / self.Vtm)
self.wf = 0.5 + 0.5 * self.T0
self.wr = 1.0 - self.wf
if (self.ASYMMOD != 0):
    self.CDSCD_a  = self.CDSCDR_i * self.wr + self.CDSCD_i * self.wf
    self.ETA0_a   = self.ETA0R_t * self.wr + self.ETA0_t * self.wf
    self.PDIBLC_a = self.PDIBLCR_i * self.wr + self.PDIBLC_i * self.wf
    self.PCLM_a   = self.PCLMR_i * self.wr + self.PCLM_i * self.wf
    self.PSAT_a   = self.PSATR_i * self.wr + self.PSAT_i * self.wf
    self.VSAT_a   = self.VSATR_t * self.wr + self.VSAT_t * self.wf
    self.PTWG_a   = self.PTWGR_t * self.wr + self.PTWG_t * self.wf
    self.U0_a     = self.U0R_t * self.wr + self.U0_t * self.wf
    self.UA_a     = self.UAR_t * self.wr + self.UA_t * self.wf
    self.UC_a     = self.UCR_t * self.wr + self.UC_t * self.wf
    self.UD_a     = self.UDR_t * self.wr + self.UD_t * self.wf
    self.UCS_a    = self.UCSR_t * self.wr + self.UCS_t * self.wf
else:
    self.CDSCD_a  = self.CDSCD_i
    self.ETA0_a   = self.ETA0_t
    self.PDIBLC_a = self.PDIBLC_i
    self.PCLM_a   = self.PCLM_i
    self.PSAT_a   = self.PSAT_i
    self.VSAT_a   = self.VSAT_t
    self.PTWG_a   = self.PTWG_t
    self.U0_a     = self.U0_t
    self.UA_a     = self.UA_t
    self.UC_a     = self.UC_t
    self.UD_a     = self.UD_t
    self.UCS_a    = self.UCS_t

# SCE, DIBL, SS degradation effects, Ref: BSIM4
self.PhistVbs = self.Smooth(self.Phist - self.Vbsx, 0.05, 0.1)
self.sqrtPhistVbs = sqrt(self.PhistVbs)
self.Xdep         = self.T1DEP * self.sqrtPhistVbs
self.Cdep         = self.epssi / self.Xdep
self.cdsc         = self.CIT_i + self.NFACTOR_t + self.CDSCD_a * self.Vdsx - self.CDSCB_i * self.Vbsx
self.T1           = 1.0 + self.cdsc/self.Cox
self.n = self.Smooth(self.T1, 1.0, 0.05)
self.nVt     = self.n * self.Vt
self.inv_nVt = 1.0 / self.nVt

# Vth shift for DIBL
self.dVth_dibl = -(self.ETA0_a + self.ETAB_i * self.Vbsx) * self.Vdsx
self.dVth_dibl = self.Smooth2(self.dVth_dibl, 0.0, 5.0e-5)

# Vth shift with temperature
self.dvth_temp = (self.KT1_i + self.KT1L / self.Leff + self.KT2_i * self.Vbsx) * (self.TRatio**self.KT1EXP - 1.0)

# Vth correction for pocket implants
if (self.DVTP0_i > 0.0):
    self.T0 = -self.DVTP1_i * self.Vdsx
    if (self.T0 < -self.EXPL_THRESHOLD):
        self.T2 = self.MIN_EXPL
    else:
        self.T2 = self.lexp(self.T0)
    self.T3        = self.Leff + self.DVTP0_i * (1.0 + self.T2)
    self.dVth_ldop = -self.nVt * self.lln(self.Leff / self.T3)
else:
    self.dVth_ldop = 0.0
self.T4        = self.DVTP5_i + self.DVTP2_i / self.Leff**self.DVTP3_i
self.dVth_ldop = self.dVth_ldop - self.T4 * tanh(self.DVTP4_i * self.Vdsx)

# Normalization of terminal and flatband voltage by nVt
self.VFB_i = self.VFB_i + self.DELVTO
self.vg    = self.Vg * self.inv_nVt
self.vs    = self.Vs * self.inv_nVt
self.vfb   = self.VFB_i * self.inv_nVt

# Compute dVth_VNUD with "first-order" and "second-order" body-bias effect
self.dVth_VNUD = self.K1_i * (self.sqrtPhistVbs - self.sqrtPhist) - self.K2_i * self.Vbsx
self.Vth_shift = self.dVth_dibl + self.dVth_ldop + self.dVth_VNUD - self.dvth_temp + self.vth0_stress + self.vth0_well
self.vgfb      = self.vg - self.vfb - self.Vth_shift * self.inv_nVt

# Threshold voltage for operating point information
self.gam     = sqrt(2.0 * self.q * self.epssi * self.NDEP_i * self.inv_Vt) / self.Cox
self.q_vth   = 0.5
self.T0      = self.hypsmooth((2.0 * self.phib + self.Vs * self.inv_Vt), 1.0e-3)
self.nq      = 1.0 + self.gam / (2.0 * sqrt(self.T0))
self.psip_th = self.hypsmooth((self.Vs * self.inv_Vt + 2.0 * self.phib + self.lln(self.q_vth) + 2.0 * self.q_vth + self.lln(2.0 * self.nq / self.gam * (2.0 * self.q_vth * self.nq / self.gam + 2.0 * sqrt(self.T0)))), 1.0e-3)
self.VTH     = self.devsign * (self.VFB_i + (self.psip_th - self.Vs * self.inv_Vt) * self.Vt + self.Vt * self.gam * sqrt(self.psip_th) + self.Vth_shift)

# Normalized body factor
self.gam     = sqrt(2.0 * self.q * self.epssi * self.NDEP_i * self.inv_nVt) / self.Cox
self.inv_gam = 1.0 / self.gam

# psip: pinch-off voltage
self.phib_n = self.phib / self.n
self.psip = self.PO_psip(self.vgfb, self.gam, 0.0)

# Normalized inversion charge at source end of channel
self.qs = self.BSIM_q(self.psip, self.phib_n, self.vs, self.gam)

# Average charge-surface potential slope, Ref: Charge-based MOS Transistor Modeling by C. Enz & E. Vittoz
self.psipclamp = self.Smooth(self.psip, 1.0, 2.0)
self.sqrtpsip = sqrt(self.psipclamp)

# Source side surface potential
self.psiavg = self.psip - 2.0 * self.qs
self.T0 = self.Smooth(self.psiavg, 1.0, 2.0)
self.nq = 1.0 + self.gam / (self.sqrtpsip + sqrt(self.T0))

# Drain saturation voltage
self.EeffFactor = 1.0e-8 / (self.epsratio * self.TOXE)
self.T0 = self.nVt * (self.vgfb - self.psip - 2.0 * self.qs * (self.nq - 1.0))
self.qbs = self.Smooth(self.T0, 0.0, 0.1)

# Source side qi and qb for Vdsat- normalized to Cox
self.qis = 2.0 * self.nq * self.nVt * self.qs
self.Eeffs = self.EeffFactor * (self.qbs + self.eta_mu * self.qis)

# Ref: BSIM4 mobility model
self.T2 = (0.5 * (1.0 + (self.qis / self.qbs)))**self.UCS_a
self.T3 = (self.UA_a + self.UC_a * self.Vbsx) * self.Eeffs**self.EU_t + self.UD_a / self.T2
self.T4 = 1.0 + self.T3
self.Dmobs = self.Smooth(self.T4, 1.0, 0.0015)
self.WeffWRFactor = 1.0 / ((self.Weff * 1.0e6)**self.WR_i * self.NF)

if (self.RDSMOD == 1):
    self.Rdss = 0.0
else:
    self.T0   = 1.0 + self.PRWG_i * self.qis
    self.T1   = self.PRWB_i * (self.sqrtPhistVbs - self.sqrtPhist)
    self.T2   = 1.0 / self.T0 + self.T1
    self.T3   = self.T2 + sqrt(self.T2 * self.T2 + 0.01)
    self.Rdss = (self.RDSWMIN_i + self.RDSW_i * self.T3) * self.WeffWRFactor * self.NF * self.rdstemp
    if (self.RDSMOD == 2):
        self.Rdss = (self.RSourceGeo + (self.RDSWMIN_i + self.RDSW_i * self.T3) * self.WeffWRFactor * self.NF + self.RDrainGeo) * self.rdstemp

self.T0  = self.Dmobs**(1.0 / self.PSAT_a)
self.T11 = self.PSATB_i * self.Vbsx
self.T12 = sqrt(0.1 + self.T11 * self.T11)
self.T1  = 0.5*(1 - self.T11 + sqrt((1 - self.T11) * (1 - self.T11) + self.T12))
self.T2  = 10.0 * self.PSATX * self.qs * self.T1 / (10.0 * self.PSATX + self.qs * self.T1)
if (self.PTWG_a < 0.0):
    self.LambdaC = 2.0 * ((self.U0_a / self.T0) * self.nVt / (self.VSAT_a * self.Leff)) * (1.0 / (1.0 - self.PTWG_a * self.T2))
else:
    self.LambdaC = 2.0 * ((self.U0_a / self.T0) * self.nVt / (self.VSAT_a * self.Leff)) * (1.0 + self.PTWG_a * self.T2)

# qdsat for external Rds
if (self.Rdss == 0):
    # Accurate qdsat derived from consistent I-V
    self.T0 = 0.5 * self.LambdaC * (self.qs * self.qs + self.qs) / (1.0 + 0.5 * self.LambdaC * (1.0 + self.qs))
    self.T1 = 2.0 * self.LambdaC * (self.qs - self.T0)
    self.T2 = sqrt(1.0 + self.T1 * self.T1)
    self.ln_T1_T2 = asinh(self.T1)
    if (self.T1 != 0.0):
        self.T3 = self.T2 + (1.0 / self.T1) * self.ln_T1_T2
    else:
        self.T3 = self.T2 + (1.0 / self.T2)
    self.T4 = self.T0 * self.T3 - self.LambdaC * ((self.qs * self.qs + self.qs) - (self.T0 * self.T0 + self.T0))
    if (self.T1 != 0.0):
        self.T5 = -2.0 * self.LambdaC * (self.T1 * self.T2 - self.ln_T1_T2) / (self.T1 * self.T1)
    else:
        self.T5 = -2.0 * self.LambdaC * (self.T1/self.T2) * (self.T1/self.T2) *(self.T1/self.T2)

    self.T6 = self.T0 * self.T5 + self.T3 + self.LambdaC * (2.0 * self.T0 + 1.0)
    self.T0 = self.T0 - (self.T4 / self.T6)
    self.T1 = 2.0 * self.LambdaC * (self.qs - self.T0)
    self.T2 = sqrt(1.0 + self.T1 * self.T1)
    self.ln_T1_T2 = asinh(self.T1)
    if (self.T1 != 0.0):
        self.T3 = self.T2 + (1.0 / self.T1) * self.ln_T1_T2
    else:
        self.T3 = self.T2 + (1.0 / self.T2)
    self.T4 = self.T0 * self.T3 - self.LambdaC * ((self.qs * self.qs + self.qs) - (self.T0 * self.T0 + self.T0))
    if (self.T1 != 0.0):
        self.T5 = -2.0 * self.LambdaC * (self.T1 * self.T2 - self.ln_T1_T2) / (self.T1 * self.T1)
    else:
        self.T5 = (self.T1 / self.T2) * (self.T1 / self.T2) * (self.T1 / self.T2)

    self.T6    = self.T0 * self.T5 + self.T3 + self.LambdaC * (2.0 * self.T0 + 1.0)
    self.qdsat = self.T0 - (self.T4/self.T6)
# qdsat for internal Rds, Ref: BSIM4
else:
    # Accurate qdsat derived from consistent I-V
    self.T11 = self.Weff * 2.0 * self.nq * self.Cox * self.nVt * self.VSAT_a
    self.T12 = self.T11 * self.LambdaC * self.Rdss / (2.0 * self.nVt)
    self.T0  = 0.5 * self.LambdaC * (self.qs * self.qs + self.qs) / (1.0 + 0.5 * self.LambdaC * (1.0 + self.qs))
    self.T1  = 2.0 * self.LambdaC * (self.qs - self.T0)
    self.T2  = sqrt(1.0 + self.T1 * self.T1)
    self.ln_T1_T2 = asinh(self.T1)
    if (self.T1 != 0.0):
        self.T3 = self.T2 + (1.0 / self.T1) * self.ln_T1_T2
    else:
        self.T3 = self.T2 + (1.0 / self.T2)
    self.T4 = self.T0 * self.T3 + self.T12 * self.T0 * (self.qs + self.T0 + 1.0) - self.LambdaC * ((self.qs * self.qs + self.qs) - (self.T0 * self.T0 + self.T0))
    if (self.T1 != 0.0):
        self.T5 = -2.0 * self.LambdaC * (self.T1 * self.T2 - self.ln_T1_T2) / (self.T1 * self.T1)
    else:
        self.T5 = -2.0 * self.LambdaC * (self.T1 / self.T2) * (self.T1 / self.T2) * (self.T1 / self.T2)
    self.T6 = self.T0 * self.T5 + self.T3 + self.T12 * (self.qs + 2.0 * self.T0 + 1.0) + self.LambdaC * (2.0 * self.T0 + 1.0)
    self.T0 = self.T0 - self.T4 / self.T6
    self.T1 = 2.0 * self.LambdaC * (self.qs - self.T0)
    self.T2 = sqrt(1.0 + self.T1 * self.T1)
    self.ln_T1_T2 = asinh(self.T1)
    if (self.T1 != 0):
        self.T3 = self.T2 + (1.0 / self.T1) * self.ln_T1_T2
    else:
        self.T3 = self.T2 + (1.0 / self.T2)
    self.T4 = self.T0 * self.T3 + self.T12 * self.T0 * (self.qs + self.T0 + 1.0) - self.LambdaC * ((self.qs * self.qs + self.qs) - (self.T0 * self.T0 + self.T0))
    if (self.T1 != 0.0):
        self.T5 = -2.0 * self.LambdaC * (self.T1 * self.T2 - self.ln_T1_T2) / (self.T1 * self.T1)
    else:
        self.T5 = -2.0 * self.LambdaC * (self.T1 / self.T2) * (self.T1 / self.T2) * (self.T1 / self.T2)
    self.T6    = self.T0 * self.T5 + self.T3 + self.T12 * (self.qs + 2.0 * self.T0 + 1.0) + self.LambdaC * (2.0 * self.T0 + 1.0)
    self.qdsat = self.T0 - self.T4 / self.T6
self.vdsat = self.psip - 2.0 * self.phib_n - (2.0 * self.qdsat + self.lln((self.qdsat * 2.0 * self.nq * self.inv_gam) * ((self.qdsat * 2.0 * self.nq * self.inv_gam) + (self.gam / (self.nq - 1.0)))))
self.Vdsat = self.vdsat * self.nVt

# Normalized charge qdeff at drain end of channel
# Vdssat clamped to avoid negative values during transient simulation
self.Vdssat = self.Smooth(self.Vdsat - self.Vs, 0.0, 1.0e-3)
self.T7      = (self.Vds / self.Vdssat)**(1.0 / self.DELTA_t)
self.T8      = (1.0 + self.T7)**-self.DELTA_t
self.Vdseff  = self.Vds * self.T8
self.vdeff   = (self.Vdseff + self.Vs) * self.inv_nVt
self.qdeff = self.BSIM_q(self.psip, self.phib_n, self.vdeff, self.gam)

# Reevaluation of nq to include qdeff
self.psiavg = self.psip - self.qs - self.qdeff -1.0
self.T0 = self.Smooth(self.psiavg, 1.0, 2.0)
self.T2 = sqrt(self.T0)
self.nq = 1.0 + self.gam / (self.sqrtpsip + self.T2)

# Inversion and bulk charge
self.DQSD2 = (self.qs - self.qdeff) * (self.qs - self.qdeff)
self.T0    = 1.0 / (1.0 + self.qs + self.qdeff)
self.T1    = self.DQSD2 * self.T0
self.Qb    = self.vgfb - self.psip - (self.nq - 1.0) * (self.qs + self.qdeff + self.Oneby3 * self.T1)
self.T2    = self.Oneby3 * self.nq
self.T3    = self.T1 * self.T0
self.Qs    = self.T2 * (2.0 * self.qs + self.qdeff + 0.5 * (1.0 + 0.8 * self.qs + 1.2 * self.qdeff) * self.T3)
self.Qd    = self.T2 * (self.qs + 2.0 * self.qdeff + 0.5 * (1.0 + 1.2 * self.qs + 0.8 * self.qdeff) * self.T3)

# Mobility degradation, Ref: BSIM4
# Average charges (qba and qia) - normalized to Cox
self.qba = self.Smooth(self.nVt * self.Qb, 0.0, 0.1)
self.qia   = self.nVt * (self.Qs + self.Qd)

self.Eeffm = self.EeffFactor * (self.qba + self.eta_mu * self.qia)
self.T2    = (0.5 * (1.0 + (self.qia / self.qba)))**self.UCS_a
self.T3    = (self.UA_a + self.UC_a * self.Vbsx) * self.Eeffm**self.EU_t + self.UD_a / self.T2
self.T4    = 1.0 + self.T3
self.Dmob = self.Smooth(self.T4, 1.0, 0.0015)

# Output conductance
self.Esat  = 2.0 * self.VSAT_a / (self.U0_a / self.Dmob)
self.EsatL = self.Esat * self.Leff
if (self.PVAG_i > 0.0):
    self.PVAGfactor = 1.0 + self.PVAG_i * self.qia / self.EsatL
else:
    self.PVAGfactor = 1.0 / (1.0 - self.PVAG_i * self.qia / self.EsatL)

# Output conductance due to DIBL, Ref: BSIM4
self.DIBLfactor = self.PDIBLC_a
self.diffVds    = self.Vds - self.Vdseff
self.Vgst2Vtm   = self.qia + 2.0 * self.nVt
if (self.DIBLfactor > 0.0):
    self.T3     = self.Vgst2Vtm / (self.Vdssat + self.Vgst2Vtm)
    self.T4     = self.hypsmooth((1.0 + self.PDIBLCB_i * self.Vbsx), 1.0e-3)
    self.T5     = 1.0 / self.T4
    self.VaDIBL = self.Vgst2Vtm / self.DIBLfactor * self.T3 * self.PVAGfactor * self.T5
    self.Moc    = 1.0 + self.diffVds / self.VaDIBL
else:
    self.Moc = 1.0

# Degradation factor due to pocket implants, Ref: BSIM4
if (self.FPROUT_i <= 0.0):
    self.Fp = 1.0
else:
    self.T9 = self.FPROUT_i * sqrt(self.Leff) / self.Vgst2Vtm
    self.Fp = 1.0 / (1.0 + self.T9)

# Channel length modulation, Ref: BSIM4
self.Vasat = self.Vdssat + self.EsatL
if (self.PCLM_a != 0.0):
    if (self.PCLMG < 0.0):
        self.T1 = self.PCLM_a / (1.0 - self.PCLMG * self.qia / self.EsatL) / self.Fp
    else:
        self.T1 = self.PCLM_a * (1.0 + self.PCLMG * self.qia / self.EsatL) / self.Fp

    self.MdL = 1.0 + self.T1 * self.lln(1.0 + self.diffVds / self.T1 / self.Vasat)
else:
    self.MdL = 1.0
self.Moc = self.Moc * self.MdL

# Calculate Va_DITS, Ref: BSIM4
self.T1 = self.lexp(self.PDITSD_i * self.Vds)
if (self.PDITS_i > 0.0):
    self.T2      = 1.0 + self.PDITSL * self.Leff
    self.VaDITS  = (1.0 + self.T2 * self.T1) / self.PDITS_i
    self.VaDITS  = self.VaDITS * self.Fp
else:
    self.VaDITS  = self.MAX_EXPL
self.T4  = self.diffVds / self.VaDITS
self.T0  = 1.0 + self.T4
self.Moc = self.Moc * self.T0

# Calculate Va_SCBE, Ref: BSIM4
if (self.PSCBE2_i > 0.0):
    if (self.diffVds > self.PSCBE1_i * self.litl / self.EXPL_THRESHOLD):
        self.T0     = self.PSCBE1_i * self.litl / self.diffVds
        self.VaSCBE = self.Leff * self.lexp(self.T0) / self.PSCBE2_i
    else:
        self.VaSCBE = self.MAX_EXPL * self.Leff/self.PSCBE2_i
else:
    self.VaSCBE = self.MAX_EXPL
self.Mscbe = 1.0 + (self.diffVds / self.VaSCBE)
self.Moc   = self.Moc * self.Mscbe

# Velocity saturation
self.T0  = self.Dmob**(1.0 / self.PSAT_a)
self.T11 = self.PSATB_i * self.Vbsx
self.T12 = sqrt(0.1+self.T11*self.T11)
self.T1  = 0.5*(1-self.T11+sqrt((1-self.T11)*(1-self.T11)+self.T12))
self.T2  = 10.0 * self.PSATX * self.qia * self.T1 / (10.0 * self.PSATX + self.qia * self.T1)
if (self.PTWG_a < 0.0):
    self.LambdaC = 2.0 * ((self.U0_a / self.T0) * self.nVt / (self.VSAT_a * self.Leff)) * (1.0 / (1.0 - self.PTWG_a * self.T2))
else:
    self.LambdaC = 2.0 * ((self.U0_a / self.T0) * self.nVt / (self.VSAT_a * self.Leff)) * (1.0 + self.PTWG_a * self.T2)
self.T1 = 2.0 * self.LambdaC * (self.qs - self.qdeff)
self.T2 = sqrt(1.0 + self.T1 * self.T1)
if (self.T1 != 0.0):
    self.Dvsat = 0.5 * (self.T2 + (1.0 / self.T1) * asinh(self.T1))
else:
    self.Dvsat = 0.5 * (self.T2 + (1.0 / self.T2))
self.Dptwg = self.Dvsat

# S/D series resistances, Ref: BSIM4
if (self.RDSMOD == 1):
    self.Rdsi = 0.0
    self.Dr   = 1.0
    # Rs (Source side resistance for all fingers)
    self.T2      = self.Vgs_noswap - self.Vfbsdr
    self.T3      = sqrt(self.T2 * self.T2 + 0.01)
    self.Vgs_eff = 0.5 * (self.T2 + self.T3)
    self.T5      = 1.0 + self.PRWG_i * self.Vgs_eff
    self.T6      = (1.0 / self.T5) + self.PRWB_i * self.Vsb_noswap
    self.T4      = 0.5 * (self.T6 + sqrt(self.T6 * self.T6 + 0.01))
    self.Rsource = self.rdstemp * (self.RSourceGeo + (self.RSWMIN_i + self.RSW_i * self.T4) * self.WeffWRFactor)
    # Rd (Drain side resistance for all fingers)
    self.T2      = self.Vgd_noswap - self.Vfbsdr
    self.T3      = sqrt(self.T2 * self.T2 + 0.01)
    self.Vgd_eff = 0.5 * (self.T2 + self.T3)
    self.T5      = 1.0 + self.PRWG_i * self.Vgd_eff
    self.T6      = (1.0 / self.T5) + self.PRWB_i * self.Vdb_noswap
    self.T4      = 0.5 * (self.T6 + sqrt(self.T6 * self.T6 + 0.01))
    self.Rdrain  = self.rdstemp * (self.RDrainGeo + (self.RDWMIN_i + self.RDW_i * self.T4) * self.WeffWRFactor)
else:
    # Ref: (1) BSIM4 (2) "Operation and Modeling of the MOS Transistor" by Yannis Tsividis
    self.T0      = 1.0 + self.PRWG_i * self.qia
    self.T1      = self.PRWB_i * (self.sqrtPhistVbs - self.sqrtPhist)
    self.T2      = 1.0 / self.T0 + self.T1
    self.T3      = 0.5 * (self.T2 + sqrt(self.T2 * self.T2 + 0.01))
    self.Rdsi    = self.rdstemp * (self.RDSWMIN_i + self.RDSW_i * self.T3) * self.WeffWRFactor * self.NF
    self.Rdrain  = self.RDrainGeo
    self.Rsource = self.RSourceGeo
    self.Dr      = 1.0 + self.U0_a /(self.Dvsat * self.Dmob) * self.Cox * self.Weff / self.Leff * self.qia * self.Rdsi
    if (self.RDSMOD == 2):
        self.Rdsi    = self.rdstemp * (self.RSourceGeo + (self.RDSWMIN_i + self.RDSW_i * self.T3) * self.WeffWRFactor * self.NF + self.RDrainGeo)
        self.Rdrain  = 0.0
        self.Rsource = 0.0
        self.Dr      = 1.0 + self.U0_a /(self.Dvsat * self.Dmob) * self.Cox * self.Weff / self.Leff * self.qia * self.Rdsi

# Non-saturation effect
self.T0   = self.A1_t + self.A2_t / (self.qia + 2.0 * self.n * self.Vtm)
self.DQSD = self.qs - self.qdeff
self.T1   = self.T0 * self.DQSD * self.DQSD
self.T2   = self.T1 + 1.0 - 0.001
self.T3   = -1.0 + 0.5 * (self.T2 + sqrt(self.T2 * self.T2 + 0.004))
self.Nsat = 0.5 * (1.0 + sqrt(1.0 + self.T3))

# MNUD model to enhance Id-Vd fitting flexibility
self.T0   = (self.qs + self.qdeff)
self.T1   = (self.qs - self.qdeff)
self.T2   = self.T1 / (self.T0 + self.M0_t)
self.T3   = self.K0_t * self.T2 * self.T2
self.Mnud = 1.0 + self.T3

# MNUD1 to enhance the fitting flexiblity for the gm/Id - similar approach used in BSIM-CMG
self.T9    = self.C0_t / (max(0, self.C0SI_t + self.C0SISAT_t * self.T1 * self.T1) * self.T0 + 2.0 * self.n * self.Vtm)
self.Mnud1 = self.lexp(-self.T9)
self.Dtot  = self.Dmob * self.Dvsat * self.Dr

# Effective mobility including mobility degradation
self.ueff = self.U0_a / self.Dtot

# I-V
self.ids  = 2.0 * self.NF * self.nq * self.ueff * self.Weff / self.Leff * self.Cox * self.nVt * self.nVt * ((self.qs - self.qdeff) * (1.0 + self.qs + self.qdeff)) * self.Moc / self.Nsat * self.Mnud * self.Mnud1
self.ids  = self.ids * self.IDS0MULT

# High-voltage model s: Ref. - Harshit Agarwal et.al., IEEE TED vol. 66, issue 10, pp. 4258, 2019
if (self.RDSMOD == 1 and self.HVMOD == 1):
    self.T4  = 1 + self.PDRWB * self.Vbsx
    self.T0  = self.ids
    self.T11 = self.NF * self.Weff * self.q  * self.VDRIFT_t
    if (self.RDLCW != 0):
        self.idrift_sat_d = self.T11 * self.NDRIFTD
        self.delta_hv = self.ids**(4 - self.MDRIFT) / (self.ids**(4 - self.MDRIFT) + self.HVFACTOR * self.idrift_sat_d**(4 - self.MDRIFT))
        self.T5  = self.T0/self.idrift_sat_d
        if (self.T5 >= 0.99):
            self.T5  = 0.5 * ((self.T5 + 0.99) - sqrt( (self.T5 - 0.99) * (self.T5 - 0.99) + 1.0e-6) + 0.001)
        self.T0D = self.delta_hv * self.T5**self.MDRIFT
        self.T1D = 1.0 - self.T0D
        self.T2D = self.T1D**(1.0 / self.MDRIFT)
        self.rdrift_d = self.rdstemphv * self.RDLCW * self.WeffWRFactor/self.T2D * self.T4
        self.IDRIFTSATD = self.idrift_sat_d
        if (self.rdrift_d < 0):
            self.rdrift_d = 0
    if (self.RSLCW != 0):
        self.idrift_sat_s = self.T11 * self.NDRIFTS
        self.delta_hv = self.ids**(4 - self.MDRIFT) / (self.ids**(4 - self.MDRIFT) + self.HVFACTOR * self.idrift_sat_s**(4 - self.MDRIFT))
        self.T5  = self.T0/self.idrift_sat_s
        if (self.T5 >= 0.99):
            self.T5  = 0.5 * ((self.T5 + 0.99) - sqrt( (self.T5 - 0.99) * (self.T5 - 0.99) + 1.0e-6) + 0.001 )
        self.T0S = self.delta_hv * self.T5**self.MDRIFT
        self.T1S = 1.0 - self.T0S
        self.T2S = self.T1S**(1.0 / self.MDRIFT)
        self.rdrift_s = self.rdstemphv * self.RSLCW * self.WeffWRFactor/self.T2S * self.T4
        if (self.rdrift_s < 0.0):
            self.rdrift_s = 0.0
    self.Rdrain  = self.Rdrain + self.rdrift_d
    self.Rsource = self.Rsource + self.rdrift_s

# CV calculations for HVMOD
if (self.RDSMOD == 1 and self.HVCAP == 1 and self.HVMOD == 1):
    self.vgfbdrift = -self.devsign * (self.VG - self.VD) - self.VFBOV
    self.vgfbdrift = self.vgfbdrift/self.Vt
    self.gamhv     = sqrt(2.0 * self.q * self.epssi * self.NDR * self.inv_Vt) / self.Cox
    self.phibHV    = self.lln(self.NDR / self.ni)
    self.psip_k = self.PO_psip(self.vgfbdrift, self.gamhv, 0.0)
    self.q_k = self.BSIM_q(self.psip_k, self.phibHV, self.devsign * (self.VD - self.VB) / self.Vt, self.gamhv)

    # calculate nq for the drift region
    self.psipclamp_hv = self.Smooth(self.psip_k, 1.0, 2.0)
    self.sqrtpsip_k = sqrt(self.psipclamp_hv)
    self.psiavg_hv = self.psip_k - 2.0 * self.q_k
    self.T0 = self.Smooth(self.psiavg_hv, 1.0, 2.0)
    self.nq_hv = 1.0 + self.gamhv / (self.sqrtpsip_k + sqrt(self.T0))
    self.psi_k = self.psip_k - 2 * self.q_k

    # contribution due to accumulation of the overlap region
    self.QBOV = self.NF * self.Wact * self.LOVER * self.EPS0 * self.EPSROX / self.BSIMBULKTOXP * self.Vt * (self.vgfbdrift - self.psi_k - 2 * self.nq_hv * self.q_k)

    # contribution due to inversion of the overlap region
    if (self.SLHV > 0):
        self.T1 = 1 + self.q_k / self.SLHV1
        self.T2 = self.SLHV * 1.9e-9 / self.T1
        self.T0 = 3.9 * self.EPS0 / (self.BSIMBULKTOXP * 3.9 / self.EPSROX + self.T2 / self.epsratio)
    else:
        self.T0 = self.EPS0 * self.EPSROX / self.BSIMBULKTOXP

    self.QIOV = self.NF * self.Wact * self.LOVERACC * 2 * self.nq_hv * self.Vt * self.T0 * self.q_k

    # For symmetric device, adding contribution of the source side drift region
    if (self.HVCAPS == 1):
        self.vgfbdrift = -self.devsign * (self.VG - self.VS) - self.VFBOV
        self.vgfbdrift = self.vgfbdrift/self.Vt
        self.psip_k = self.PO_psip(self.vgfbdrift, self.gamhv, 0.0)
        self.q_k = self.BSIM_q(self.psip_k, self.phibHV, self.devsign * (self.VS - self.VB) / self.Vt, self.gamhv)
        self.psipclamp_hv = self.Smooth(self.psip_k, 1.0, 2.0)
        self.sqrtpsip_k = sqrt(self.psipclamp_hv)
        self.psiavg_hv = self.psip_k - 2.0 * self.q_k
        self.T0 = self.Smooth(self.psiavg_hv, 1.0, 2.0)
        self.nq_hv = 1.0 + self.gamhv / (self.sqrtpsip_k + sqrt(self.T0))
        self.psi_k = self.psip_k - 2 * self.q_k
        self.QBOVS = self.NF * self.Wact * self.LOVER * self.EPS0 * self.EPSROX / self.BSIMBULKTOXP * self.Vt * (self.vgfbdrift - self.psi_k - 2 * self.nq_hv * self.q_k)
        if (self.SLHV > 0):
            self.T1 = 1 + self.q_k / self.SLHV1
            self.T2 = self.SLHV * 1.9e-9 / self.T1
            self.T0 = 3.9 * self.EPS0 / (self.BSIMBULKTOXP * 3.9 / self.EPSROX + self.T2 / self.epsratio)
        else:
            self.T0 = self.EPS0 * self.EPSROX / self.BSIMBULKTOXP
        self.QIOVS = self.NF * self.Wact * self.LOVERACC * 2 * self.nq_hv * self.Vt * self.T0 * self.q_k
if (self.RGATEMOD > 1):
    self.idsovvds = self.ueff * self.Weff / self.Leff * self.Cox * self.qia
    self.T9       = self.XRCRG2 * self.Vt
    self.T0       = self.T9 * self.ueff * self.Weff / self.Leff * self.Cox
    self.Gcrg     = self.XRCRG1 * self.NF * (self.T0 + self.idsovvds)
    if (self.RGATEMOD == 2):
        self.T11  = self.Grgeltd + self.Gcrg
        self.Gcrg = self.Grgeltd * self.Gcrg / self.T11

# Impact ionization currents, Ref: BSIM4
if ((self.ALPHA0_i <= 0.0) or (self.BETA0_t <= 0.0)):
    self.Iii = 0.0
elif (self.diffVds > self.BETA0_t / self.EXPL_THRESHOLD):
    self.T1  = -self.BETA0_t / self.diffVds
    self.Iii = self.ALPHA0_i * self.diffVds * self.ids * self.lexp(self.T1) / self.Mscbe
else:
    self.Iii = self.ALPHA0_i * self.diffVds * self.ids * self.MIN_EXPL / self.Mscbe

# Secondary impact ionization in the drift region
if (self.HVMOD == 1 and self.IIMOD == 1):
    self.Ntot = self.DRII1 * self.ids/(self.NF * self.Weff * self.q  * self.VDRIFT_t )
    self.Nextra = self.Ntot/self.NDRIFTD - 1
    self.Nextra = self.Smooth(self.Nextra, 0, self.DELTAII)
    self.Nextra = self.NDRIFTD * self.Nextra
    self.T2 = self.Smooth(self.devsign * (self.VD - self.VB) - self.Vdseff - self.DRII2, 0, 0.05)
    self.T3 = 2.0 * self.q /(self.EPSRSUB * self.EPS0) * self.Nextra
    self.T3 = self.T3 * self.T2
    if (self.T3 > self.BETADR / self.EXPL_THRESHOLD):
        self.T1  = -self.BETADR/self.T3
        self.IsubDR = self.ALPHADR * self.T2 * self.ids * self.lexp(self.T1)
    else:
        self.IsubDR = self.ALPHADR * self.T2 * self.ids * self.MIN_EXPL
    self.Iii = self.Iii + self.IsubDR

# Gate currents, Ref: BSIM4
if ((self.IGCMOD != 0) or (self.IGBMOD != 0)):
    self.Voxm    = self.nVt * (self.vgfb - self.psip + self.qs + self.qdeff)
    self.T1      = sqrt(self.Voxm * self.Voxm + 1.0e-4)
    self.Voxmacc = 0.5 * (-self.Voxm + self.T1)
    self.Voxminv = 0.5 * (self.Voxm + self.T1)
    # Igbinv
    if (self.IGBMOD != 0):
        self.T1     = self.Voxm / self.NIGBACC_i / self.Vt
        self.Vaux_Igbacc = self.NIGBACC_i * self.Vt * self.lln(1.0 + self.lexp(-self.T1))
        self.T2     = self.AIGBACC_i - self.BIGBACC_i * self.Voxmacc
        self.T3     = 1.0 + self.CIGBACC_i * self.Voxmacc
        self.T4     = -7.45669e11 * self.TOXE * self.T2 * self.T3
        self.T5     = self.lexp(self.T4)
        self.T6     = 4.97232e-7
        self.igbacc = self.NF * self.Weff * self.Leff * self.T6 * self.ToxRatio * self.Vg * self.Vaux_Igbacc * self.T5
        self.igbacc = self.igbacc * self.igtemp
        self.T1     = (self.Voxm - self.EIGBINV_i) / self.NIGBINV_i / self.Vt
        self.Vaux_Igbinv = self.NIGBINV_i * self.Vt * self.lln(1.0 + self.lexp(self.T1))
        self.T2     = self.AIGBINV_i - self.BIGBINV_i * self.Voxminv
        self.T3     = 1.0 + self.CIGBINV_i * self.Voxminv
        self.T4     = -9.82222e11 * self.TOXE * self.T2 * self.T3
        self.T5     = self.lexp(self.T4)
        self.T6     = 3.75956e-7
        self.igbinv = self.NF * self.Weff * self.Leff * self.T6 * self.ToxRatio * self.Vg * self.Vaux_Igbinv * self.T5
        self.igbinv = self.igbinv * self.igtemp
        self.igb    = self.igbacc + self.igbinv
    if (self.IGCMOD != 0):
        # Igcinv
        self.T1   = self.AIGC_i - self.BIGC_i * self.Voxminv
        self.T2   = 1.0 + self.CIGC_i * self.Voxminv
        self.T3   = self.Bechvb * self.T1 * self.T2
        self.T4   = self.nq * self.nVt * (self.qs + self.qdeff) * self.lexp(self.T3)
        self.igc0 = self.NF * self.Aechvb * self.T4 * (self.Vg + 0.5 * self.Vdsx - 0.5 * (self.Vs + self.Vd)) * self.igtemp
        # Gate-current partitioning
        self.Vdseffx = sqrt(self.Vdseff * self.Vdseff + 0.01) - 0.1
        self.T1      = self.PIGCD_i * self.Vdseffx
        self.T1_exp  = self.lexp(-self.T1)
        self.T3      = self.T1 + self.T1_exp -1.0 + 1.0e-4
        self.T4      = 1.0 - (self.T1 + 1.0) * self.T1_exp + 1.0e-4
        self.T5      = self.T1 * self.T1 + 2.0e-4
        if (self.sigvds > 0):
            self.igcd = self.igc0 * self.T4 / self.T5
            self.igcs = self.igc0 * self.T3 / self.T5
        else:
            self.igcs = self.igc0 * self.T4 / self.T5
            self.igcd = self.igc0 * self.T3 / self.T5
        # Igs
        self.T2      = self.Vgs_noswap - self.Vfbsdr
        self.Vgs_eff = sqrt(self.T2 * self.T2 + 1.0e-4)
        if (self.IGCLAMP == 1):
            self.T1 = self.hypsmooth((self.AIGS_i - self.BIGS_i * self.Vgs_eff), 1.0e-6)
            if (self.CIGS_i < 0.01):
                self.CIGS_i = 0.01
        else:
            self.T1 = self.AIGS_i - self.BIGS_i * self.Vgs_eff

        self.T2       = 1.0 + self.CIGS_i * self.Vgs_eff
        self.T3       = self.BechvbEdge * self.T1 * self.T2
        self.T4       = self.lexp(self.T3)
        self.igs_mult = self.igtemp * self.NF * self.AechvbEdge * self.DLCIG_i
        self.igs      = self.igs_mult * self.Vgs_noswap * self.Vgs_eff * self.T4
        # Igd
        self.T2      = self.Vgd_noswap - self.Vfbsdr
        self.Vgd_eff = sqrt(self.T2 * self.T2 + 1.0e-4)
        if (self.IGCLAMP == 1):
            self.T1 = self.hypsmooth((self.AIGD_i - self.BIGD_i * self.Vgd_eff), 1.0e-6)
            if (self.CIGD_i < 0.01):
                self.CIGD_i = 0.01
        else:
            self.T1 = self.AIGD_i - self.BIGD_i * self.Vgd_eff
        self.T2       = 1.0 + self.CIGD_i * self.Vgd_eff
        self.T3       = self.BechvbEdge * self.T1 * self.T2
        self.T4       = self.lexp(self.T3)
        self.igd_mult = self.igtemp * self.NF * self.AechvbEdge * self.DLCIGD_i
        self.igd      = self.igd_mult * self.Vgd_noswap * self.Vgd_eff * self.T4

# GIDL and GISL currents, Ref: BSIM4
if (self.GIDLMOD != 0):
    self.T0 = self.epsratio * self.TOXE
    # GIDL
    if ((self.AGIDL_i <= 0.0) or (self.BGIDL_t <= 0.0) or (self.CGIDL_i < 0.0)):
        self.T6 = 0.0
    else:
        self.T1 = (-self.Vgd_noswap - self.EGIDL_i + self.Vfbsdr) / self.T0
        self.T1 = self.hypsmooth(self.T1, 1.0e-2)
        self.T2 = self.BGIDL_t / (self.T1 + 1.0e-3)
        if (self.CGIDL_i != 0.0):
            self.T3 = self.Vdb_noswap * self.Vdb_noswap * self.Vdb_noswap
            self.T4 = self.CGIDL_i + abs(self.T3) + 1.0e-4
            self.T5 = self.hypsmooth(self.T3 / self.T4, 1.0e-6) - 1.0e-6
        else:
            self.T5 = 1.0
        self.T6 = self.AGIDL_i * self.Weff * self.T1 * self.lexp(-self.T2) * self.T5

    self.igidl = self.T6
    # GISL
    if ((self.AGISL_i <= 0.0) or (self.BGISL_t <= 0.0) or (self.CGISL_i < 0.0)):
        self.T6 = 0.0
    else:
        self.T1 = (-self.Vgs_noswap - self.EGISL_i + self.Vfbsdr) / self.T0
        self.T1 = self.hypsmooth(self.T1, 1.0e-2)
        self.T2 = self.BGISL_t / (self.T1 + 1.0e-3)
        if (self.CGISL_i != 0.0):
            self.T3 = self.Vsb_noswap * self.Vsb_noswap * self.Vsb_noswap
            self.T4 = self.CGISL_i + abs(self.T3) + 1.0e-4
            self.T5 = self.hypsmooth(self.T3 / self.T4, 1.0e-6) - 1.0e-6
        else:
            self.T5 = 1.0
        self.T6 = self.AGISL_i * self.Weff * self.T1 * self.lexp(-self.T2) * self.T5
    self.igisl = self.T6

# Junction currents and capacitances
# Source-side junction currents
if (self.Isbs > 0.0):
    if (self.Vbs_jct < self.VjsmRev):
        self.T0  = self.Vbs_jct / self.Nvtms
        self.T1  = self.lexp(self.T0) - 1.0
        self.T2  = self.IVjsmRev + self.SslpRev * (self.Vbs_jct - self.VjsmRev)
        self.Ibs = self.T1 * self.T2
    elif (self.Vbs_jct <= self.VjsmFwd):
        self.T0  = self.Vbs_jct / self.Nvtms
        self.T1  = (self.BVS + self.Vbs_jct) / self.Nvtms
        self.T2  = self.lexp(-self.T1)
        self.Ibs = self.Isbs * (self.lexp(self.T0) + self.XExpBVS - 1.0 - self.XJBVS * self.T2)
    else:
        self.Ibs = self.IVjsmFwd + self.SslpFwd * (self.Vbs_jct - self.VjsmFwd)
else:
    self.Ibs = 0.0

# Source-side junction tunneling currents
if (self.JTSS_t > 0.0):
    if ((self.VTSS - self.Vbs_jct) < (self.VTSS * 1.0e-3)):
        self.T0  = -self.Vbs_jct / self.Vtm0 / self.NJTS_t
        self.T1  = self.lexp(self.T0 * 1.0e3) - 1.0
        self.Ibs = self.Ibs - self.ASeff * self.JTSS_t * self.T1
    else:
        self.T0  = -self.Vbs_jct / self.Vtm0 / self.NJTS_t
        self.T1  = self.lexp(self.T0 * self.VTSS / (self.VTSS - self.Vbs_jct)) - 1.0
        self.Ibs = self.Ibs - self.ASeff * self.JTSS_t * self.T1
if (self.JTSSWS_t > 0.0):
    if ((self.VTSSWS - self.Vbs_jct) < (self.VTSSWS * 1.0e-3)):
        self.T0  = -self.Vbs_jct / self.Vtm0 / self.NJTSSW_t
        self.T1  = self.lexp(self.T0 * 1.0e3) - 1.0
        self.Ibs = self.Ibs - self.PSeff * self.JTSSWS_t * self.T1
    else:
        self.T0  = -self.Vbs_jct / self.Vtm0 / self.NJTSSW_t
        self.T1  = self.lexp(self.T0 * self.VTSSWS / (self.VTSSWS - self.Vbs_jct)) - 1.0
        self.Ibs = self.Ibs - self.PSeff * self.JTSSWS_t * self.T1
if (self.JTSSWGS_t > 0.0):
    if ((self.VTSSWGS - self.Vbs_jct) < (self.VTSSWGS * 1.0e-3)):
        self.T0  = -self.Vbs_jct / self.Vtm0 / self.NJTSSWG_t
        self.T1  = self.lexp(self.T0 * 1.0e3) - 1.0
        self.Ibs = self.Ibs - self.Weffcj * self.NF * self.JTSSWGS_t * self.T1
    else:
        self.T0  = -self.Vbs_jct / self.Vtm0 / self.NJTSSWG_t
        self.T1  = self.lexp(self.T0 * self.VTSSWGS / (self.VTSSWGS - self.Vbs_jct)) - 1.0
        self.Ibs = self.Ibs - self.Weffcj * self.NF * self.JTSSWGS_t * self.T1

# Drain-side junction currents
if (self.Isbd > 0.0):
    if (self.Vbd_jct < self.VjdmRev):
        self.T0  = self.Vbd_jct / self.Nvtmd
        self.T1  = self.lexp(self.T0) - 1.0
        self.T2  = self.IVjdmRev + self.DslpRev * (self.Vbd_jct - self.VjdmRev)
        self.Ibd = self.T1 * self.T2
    elif (self.Vbd_jct <= self.VjdmFwd):
        self.T0  = self.Vbd_jct / self.Nvtmd
        self.T1  = (self.BVD + self.Vbd_jct) / self.Nvtmd
        self.T2  = self.lexp(-self.T1)
        self.Ibd = self.Isbd * (self.lexp(self.T0) + self.XExpBVD - 1.0 - self.XJBVD * self.T2)
    else:
        self.Ibd = self.IVjdmFwd + self.DslpFwd * (self.Vbd_jct - self.VjdmFwd)
else:
    self.Ibd = 0.0

# Drain-side junction tunneling currents
if (self.JTSD_t > 0.0):
    if ((self.VTSD - self.Vbd_jct) < (self.VTSD * 1.0e-3)):
        self.T0  = -self.Vbd_jct / self.Vtm0 / self.NJTSD_t
        self.T1  = self.lexp(self.T0 * 1.0e3) - 1.0
        self.Ibd = self.Ibd - self.ADeff * self.JTSD_t * self.T1
    else:
        self.T0  = -self.Vbd_jct / self.Vtm0 / self.NJTSD_t
        self.T1  = self.lexp(self.T0 * self.VTSD/ (self.VTSD - self.Vbd_jct)) - 1.0
        self.Ibd = self.Ibd - self.ADeff * self.JTSD_t * self.T1
if (self.JTSSWD_t > 0.0):
    if ((self.VTSSWD - self.Vbd_jct) < (self.VTSSWD * 1.0e-3)):
        self.T0  = -self.Vbd_jct / self.Vtm0 / self.NJTSSWD_t
        self.T1  = self.lexp(self.T0 * 1.0e3) - 1.0
        self.Ibd = self.Ibd - self.PDeff * self.JTSSWD_t * self.T1
    else:
        self.T0  = -self.Vbd_jct / self.Vtm0 / self.NJTSSWD_t
        self.T1  = self.lexp(self.T0 * self.VTSSWD / (self.VTSSWD - self.Vbd_jct)) - 1.0
        self.Ibd = self.Ibd - self.PDeff * self.JTSSWD_t * self.T1
if (self.JTSSWGD_t > 0.0):
    if ((self.VTSSWGD - self.Vbd_jct) < (self.VTSSWGD * 1.0e-3)):
        self.T0  = -self.Vbd_jct / self.Vtm0 / self.NJTSSWGD_t
        self.T1  = self.lexp(self.T0 * 1.0e3) - 1.0
        self.Ibd = self.Ibd - self.Weffcj * self.NF * self.JTSSWGD_t * self.T1
    else:
        self.T0  = -self.Vbd_jct / self.Vtm0 / self.NJTSSWGD_t
        self.T1  = self.lexp(self.T0 * self.VTSSWGD / (self.VTSSWGD - self.Vbd_jct)) - 1.0
        self.Ibd = self.Ibd - self.Weffcj * self.NF * self.JTSSWGD_t * self.T1


# Junction capacitances (no swapping)
# Source-to-bulk junction
self.Czbs       = self.CJS_t * self.ASeff
self.Czbssw     = self.CJSWS_t * self.PSeff
self.Czbsswg    = self.CJSWGS_t * self.Weffcj * self.NF
self.czbs_p1    = 0.1**-self.MJS
self.czbs_p2    = 1.0 / (1.0 - self.MJS) * (1.0 - 0.05 * self.MJS * (1.0 + self.MJS) * self.czbs_p1)
self.czbssw_p1  = 0.1**-self.MJSWS
self.czbssw_p2  = 1.0 / (1.0 - self.MJSWS) * (1.0 - 0.05 * self.MJSWS * (1.0 + self.MJSWS) * self.czbssw_p1)
self.czbsswg_p1 = 0.1**-self.MJSWGS
self.czbsswg_p2 = 1.0 / (1.0 - self.MJSWGS) * (1.0 - 0.05 * self.MJSWGS * (1.0 + self.MJSWGS) * self.czbsswg_p1)
self.Qbsj1 = self.JunCap(self.Czbs, self.Vbs_jct, self.PBS_t, self.MJS, self.czbs_p1, self.czbs_p2)
self.Qbsj2 = self.JunCap(self.Czbssw, self.Vbs_jct, self.PBSWS_t, self.MJSWS, self.czbssw_p1, self.czbssw_p2)
self.Qbsj3 = self.JunCap(self.Czbsswg, self.Vbs_jct, self.PBSWGS_t, self.MJSWGS, self.czbsswg_p1, self.czbsswg_p2)
self.Qbsj = self.Qbsj1 + self.Qbsj2 + self.Qbsj3

# Drain-to-bulk junction
self.Czbd       = self.CJD_t * self.ADeff
self.Czbdsw     = self.CJSWD_t * self.PDeff
self.Czbdswg    = self.CJSWGD_t * self.Weffcj * self.NF
self.czbd_p1    = 0.1**-self.MJD
self.czbd_p2    = 1.0 / (1.0 - self.MJD) * (1.0 - 0.05 * self.MJD * (1.0 + self.MJD) * self.czbd_p1)
self.czbdsw_p1  = 0.1**-self.MJSWD
self.czbdsw_p2  = 1.0 / (1.0 - self.MJSWD) * (1.0 - 0.05 * self.MJSWD * (1.0 + self.MJSWD) * self.czbdsw_p1)
self.czbdswg_p1 = 0.1**-self.MJSWGD
self.czbdswg_p2 = 1.0 / (1.0 - self.MJSWGD) * (1.0 - 0.05 * self.MJSWGD * (1.0 + self.MJSWGD) * self.czbdswg_p1)
self.Qbdj1 = self.JunCap(self.Czbd, self.Vbd_jct, self.PBD_t, self.MJD, self.czbd_p1, self.czbd_p2)
self.Qbdj2 = self.JunCap(self.Czbdsw, self.Vbd_jct, self.PBSWD_t, self.MJSWD, self.czbdsw_p1, self.czbdsw_p2)
self.Qbdj3 = self.JunCap(self.Czbdswg, self.Vbd_jct, self.PBSWGD_t, self.MJSWGD, self.czbdswg_p1, self.czbdswg_p2)
self.Qbdj = self.Qbdj1 + self.Qbdj2 + self.Qbdj3

# Sub-surface leakage drain current
if (self.SSLMOD != 0):
    self.T1 = (self.NDEP_i / 1.0e23)**self.SSLEXP1
    self.T2 = (300.0 / self.DevTemp)**self.SSLEXP2
    self.T3 = (self.devsign * self.SSL5 * (self.VB - self.VS)) / self.Vt
    self.SSL0_NT  = self.SSL0 * self.lexp(-self.T1 * self.T2)
    self.SSL1_NT  = self.SSL1 * self.T2 * self.T1
    self.PHIB_SSL = self.SSL3 * tanh(self.lexp(self.devsign * self.SSL4 * ((self.VG - self.VB) - self.VTH - (self.VS - self.VB))))
    self.Issl     = self.sigvds * self.NF * self.Weff * self.SSL0_NT * self.lexp(self.T3) * self.lexp(-self.SSL1_NT * self.Leff) * self.lexp(self.PHIB_SSL / self.Vt) * (self.lexp(self.SSL2 * self.Vdsx / self.Vt) - 1.0)

# Harshit's new flicker noise model. Ref: H. Agarwal et. al., IEEE J-EDS, vol. 3, no. 4, April 2015.
self.Nt      = 4.0 * self.Vt * self.q
self.Esatnoi = 2.0 * self.VSAT_a / self.ueff
if (self.EM <= 0.0):
   self.DelClm = 0.0
else:
    self.T0     = (self.diffVds / self.litl + self.EM) / self.Esatnoi
    self.DelClm = self.litl * self.lln(self.T0)
    if (self.DelClm < 0.0):
        self.DelClm = 0.0

self.Nstar = self.Vt / self.q * (self.Cox + self.Cdep + self.CIT_i)
self.Nl    = 2.0 * self.nq * self.Cox * self.Vt * self.qdeff * self.Mnud1 * self.Mnud / self.q
self.T0a   = self.q * self.q * self.q * self.Vt * abs(self.ids) * self.ueff
self.T0b   = self.q * self.Vt * self.ids * self.ids
self.T0c   = self.NOIA + self.NOIB * self.Nl + self.NOIC * self.Nl * self.Nl
self.T0d   = (self.Nl + self.Nstar) * (self.Nl + self.Nstar)
self.T0e   = self.NOIA * self.q * self.Vt
if (self.FNOIMOD == 1):
    self.LH1 = self.LH
    if (self.Leff > self.LH1):
        self.T0 = (self.Leff - self.LH1)
    else:
        self.LH1 = self.Leff
        self.T0 = self.LH1
    if (self.LINTNOI >= self.T0 / 2.0):
        print("Warning: LINTNOI = %e is too large - Leff for noise is negative. Re-setting LINTNOI = 0.", LINTNOI)
        self.LINTNOI_i = 0.0
    else:
        self.LINTNOI_i = self.LINTNOI

    self.LeffnoiH = self.Leff
    self.vgfbh  = (self.Vg - self.VFB_i) / self.Vt
    self.gam_h  = sqrt(2.0 * self.q * self.epssi * self.HNDEP / self.Vt) / self.Cox
    self.phib_h = log(self.HNDEP / self.ni)

    # Pinch-Off potential for halo region
    self.psiph = self.PO_psip(self.vgfbh, self.gam_h, 0.0)

    # Normalized inversion charge at source end of halo MOSFET
    self.qsh = self.BSIM_q(self.psiph, self.phib_h, self.vs, self.gam_h)
    self.nq_h = 1.0 + self.gam_h / (2.0 * sqrt(self.psiph))

    # Setting mobility of halo region equal to the mobility of the channel. In general, U0H < ueff
    self.U0_i_h  = self.ueff
    self.beta_h  = self.U0_i_h * self.Cox * self.Weff
    self.beta_ch = self.ueff * self.Cox * self.Weff

    # Normalized drain current for halo transistor. Eq. (14) of the paper
    self.i1 = self.ids * self.LH1 / (2.0 * self.nq_h * self.beta_h * self.Vt * self.Vt)

    # Normalized drain current for channel transistor. Eq. (15) of the paper
    self.i2 = self.ids * (self.LeffnoiH - self.LH1) / (2.0 * self.nq * self.beta_ch * self.nVt * self.nVt)
    self.T0 = (1.0 + 4.0 * (self.qsh * self.qsh + self.qsh - self.i1))
    if (self.T0 < 1.0):
        self.qdh = 0.0
    else:
        # Drain charge of halo transistor. Eq. (16) of the paper
        self.qdh = -0.5 + 0.5 * sqrt(self.T0)

    # Source charge of channel transistor. Eq. (17) of the paper
    self.qsch   = -0.5 + 0.5 * sqrt(1.0 + 4.0 * (self.qdeff * self.qdeff + self.qdeff + self.i2))
    self.gds_h  = 2.0 * self.nq_h * self.beta_h * self.Vt * self.qdh
    self.gds_ch = 2.0 * self.nq * self.beta_ch * self.Vt * self.qdeff
    self.gm_ch  = 2.0 * self.beta_ch * self.Vt * (self.qsch - self.qdeff)
    self.R_ch   = self.gds_h * (self.LeffnoiH - self.LH1)
    self.R_h    = self.gm_ch * self.LH1 + self.gds_ch * self.LH1
    self.t_tot  = 1.0 / (self.R_ch + self.R_h) / (self.R_ch + self.R_h)
    self.CF_ch  = self.R_ch * self.R_ch * self.t_tot
    self.CF_h   = self.R_h * self.R_h * self.t_tot

    # Local noise source
    if (self.Leff != self.LH1):
        self.Np2       = 2.0 * self.nq * self.Cox * self.Vt * self.qsch / self.q
        self.Leffnoi   = self.LeffnoiH - 2.0 * self.LINTNOI_i-self.LH1
        self.Leffnoisq = self.Leffnoi * self.Leffnoi
        # Channel transistor LNS
        self.T1     = 1.0e10 * self.Cox * self.Leffnoisq
        self.T2     = self.NOIA * self.lln((self.Np2 + self.Nstar) / (self.Nl + self.Nstar))
        self.T3     = self.NOIB * (self.Np2 - self.Nl)
        self.T4     = 0.5 * self.NOIC * (self.Np2 * self.Np2 - self.Nl * self.Nl)
        self.T5     = 1.0e10 * self.Leffnoisq * self.Weff * self.NF
        self.Ssi_ch = self.T0a / self.T1 * (self.T2 + self.T3 + self.T4) + self.T0b / self.T5 * self.DelClm * self.T0c / self.T0d
        self.T6     = self.Weff * self.NF * self.Leffnoi * 1.0e10 * self.Nstar * self.Nstar
        self.Swi_ch = self.T0e / self.T6 * self.ids * self.ids
        self.T7 = self.Swi_ch + self.Ssi_ch
        if (self.T7 > 0.0):
            self.FNPowerAt1Hz_ch = (self.Ssi_ch * self.Swi_ch) / self.T7
        else:
            self.FNPowerAt1Hz_ch = 0.0
    else:
        self.FNPowerAt1Hz_ch = 0.0
    # Halo transistor LNS
    self.T8    = self.NOIA2 * self.q * self.Vt
    self.T9    = self.Weff * self.NF * self.LH1 * 1.0e10 * self.Nstar * self.Nstar
    self.Swi_h = self.T8 / self.T9 * self.ids * self.ids
    self.T10   = self.Swi_h
    if (self.T10 > 0.0):
        self.FNPowerAt1Hz_h = self.Swi_h
    else:
        self.FNPowerAt1Hz_h = 0.0
    # Overall noise
    self.FNPowerAt1Hz = self.FNPowerAt1Hz_ch * self.CF_ch + self.FNPowerAt1Hz_h * self.CF_h
else:
    # Parameter checking
    if (self.LINTNOI >= self.Leff/2.0):
        print("Warning: LINTNOI = %e is too large - Leff for noise is negative. Re-setting LINTNOI = 0.", LINTNOI)
        self.LINTNOI_i = 0.0
    else:
        self.LINTNOI_i = self.LINTNOI

    if (self.NOIA > 0.0 or self.NOIB > 0.0 or self.NOIC > 0.0):
        self.Leffnoi   = self.Leff - 2.0 * self.LINTNOI_i
        self.Leffnoisq = self.Leffnoi * self.Leffnoi
        self.T0        = 1.0e10 * self.Cox * self.Leffnoisq
        self.N0        = 2.0 * self.nq * self.Cox * self.Vt * self.qs * self.Mnud1 * self.Mnud / self.q
        self.T1        = self.NOIA * self.lln((self.N0 + self.Nstar) / (self.Nl + self.Nstar))
        self.T2        = self.NOIB * (self.N0 - self.Nl)
        self.T3        = 0.5 * self.NOIC * (self.N0 * self.N0 - self.Nl * self.Nl)
        self.T4        = 1.0e10 * self.Leffnoisq * self.Weff * self.NF
        self.Ssi       = self.T0a / self.T0 * (self.T1 + self.T2 + self.T3) + self.T0b / self.T4 * self.DelClm * self.T0c / self.T0d
        self.T5        = self.Weff * self.NF * self.Leffnoi * 1.0e10 * self.Nstar * self.Nstar
        self.Swi       = self.T0e / self.T5 * self.ids * self.ids
        self.T6        = self.Swi + self.Ssi
        if (self.T6 > 0.0):
            self.FNPowerAt1Hz = (self.Ssi * self.Swi) / self.T6 / (1 + self.NOIA1 * (self.qs-self.qdeff)**self.NOIAX)
        else:
            self.FNPowerAt1Hz = 0.0
    else:
        self.FNPowerAt1Hz = 0.0
self.T0         = self.qia / self.Esatnoi / self.Leff
self.T1         = self.T0 * self.T0
self.T3         = self.RNOIA * (1.0 + self.TNOIA * self.Leff * self.T1)
self.T4         = self.RNOIB * (1.0 + self.TNOIB * self.Leff * self.T1)
self.T5         = self.RNOIK * (1.0 + self.TNOIK * self.Leff * self.T1)
self.ctnoi      = self.RNOIC * (1.0 + self.TNOIC * self.Leff * self.T1)
self.betanoisq  = 3.0 * self.T3 * self.T3
self.betanoisq  = (self.betanoisq - 1.0) * exp(-self.Leff / self.LP) + 1.0
self.betaLowId  = self.T5 * self.T5
self.thetanoisq = self.T4 * self.T4
self.cm_igid    = 0.0

# C-V model
self.vgfbCV   = self.vgfb
self.gamg2    = (2.0 * self.q * self.epssi * self.NGATE_i) / (self.Cox * self.Cox * self.Vt)
self.invgamg2 = 0.0
if (self.CVMOD == 1):
    self.VFBCV_i = self.VFBCV_i + self.DELVTO
    self.vg      = self.Vg * self.inv_Vt
    self.vs      = self.Vs * self.inv_Vt
    self.vfb     = self.VFBCV_i * self.inv_Vt
    self.vgfbCV  = self.vg - self.vfb
    self.phibCV    = self.lln(self.NDEPCV_i / self.ni)
    # Normalized body factor
    self.gamCV      = sqrt(2.0 * self.q * self.epssi * self.NDEPCV_i * self.inv_Vt) / self.Cox
    self.inv_gam  = 1.0 / self.gamCV
    self.gamg2    = (2.0 * self.q * self.epssi * self.NGATE_i) / (self.Cox * self.Cox * self.Vt)
    self.invgamg2 = (1.0 / self.gamg2) if (self.NGATE_i > 0.0) else 0.0
    self.DPD      = (self.NDEPCV_i / self.NGATE_i) if (self.NGATE_i > 0.0) else 0.0

    # psip: pinch-off voltage
    self.psip = self.PO_psip(self.vgfbCV, self.gamCV, self.DPD)

    # Normalized inversion charge at source end of channel
    self.qs = self.BSIM_q(self.psip, self.phibCV, self.vs, self.gamCV)
    self.psipclamp = self.Smooth(self.psip, 1.0, 2.0)
    self.sqrtpsip = sqrt(self.psipclamp)

    # Source side surface potential
    self.psiavg = self.psip - 2.0 * self.qs
    self.T0 = self.Smooth(self.psiavg, 1.0, 2.0)
    self.nq = 1.0 + self.gamCV / (self.sqrtpsip + sqrt(self.T0))

    # Drain saturation voltage
    self.T0 = self.Vt * (self.vgfbCV - self.psip - 2.0 * self.qs * (self.nq - 1.0))
    self.qbs = self.Smooth(self.T0, 0.0, 0.1)

    # Source side qi and qb for Vdsat (normalized to Cox)
    self.qis = 2.0 * self.nq * self.Vt * self.qs
    self.Eeffs = self.EeffFactor * (self.qbs + self.eta_mu * self.qis)

    # Ref: BSIM4 mobility model
    self.T3 = (self.UA_a + self.UC_a * self.Vbsx) * self.Eeffs**self.EU_t
    self.T4 = 1.0 + self.T3
    self.Dmobs = self.Smooth(self.T4, 1.0, 0.0015)
    self.LambdaC_by2 = (self.U0_a / self.Dmobs) * self.Vt / (self.VSATCV_t * self.Lact)
    self.qdsat       = self.LambdaC_by2 * (self.qs * self.qs + self.qs) / (1.0 + self.LambdaC_by2 * (1.0 + self.qs))
    self.vdsatcv     = self.psip - 2.0 * self.phibCV - (2.0 * self.qdsat + self.lln((self.qdsat * 2.0 * self.nq * self.inv_gam) * ((self.qdsat * 2.0 * self.nq * self.inv_gam) + (self.gam / (self.nq - 1.0)))))
    self.VdsatCV     = self.vdsatcv * self.Vt

    # Normalized charge qdeff at drain end of channel
    self.VdssatCV = self.Smooth(self.VdsatCV - self.Vs, 0.0, 1e-3)
    self.VdssatCV     = self.VdssatCV / self.ABULK
    self.T7     = (self.Vds / self.VdssatCV)**(1.0 / self.DELTA_t)
    self.T8     = (1.0 + self.T7)**-self.DELTA_t
    self.Vdseff = self.Vds * self.T8
    self.vdeff  = (self.Vdseff + self.Vs) * self.inv_Vt
    self.qdeff = self.BSIM_q(self.psip, self.phibCV, self.vdeff, self.gamCV)

    # Reevaluation of nq to include qdeff needed for gummel symmetry
    self.psiavg = self.psip - self.qs - self.qdeff - 1.0
    self.T0 = self.Smooth(self.psiavg, 1.0, 2.0)
    self.T2 = sqrt(self.T0)
    self.T3 = 1.0 + self.DPD + self.gamCV / (self.sqrtpsip + self.T2)
    self.T4 = 0.5 + self.DPD * self.T2 * self.inv_gam
    self.T5 = sqrt(self.T4 * self.T4 + self.T3 * (self.qs + self.qdeff) * self.invgamg2)
    self.nq = self.T3 / (self.T4 + self.T5)

    # C-V expressions including velocity saturation and CLM
    # Velocity saturation for C-V
    self.T0  = self.Vt * (self.vgfbCV - self.psip - 2.0 * self.qs * (self.nq - 1.0))
    self.qbs = self.Smooth(self.T0, 0.0, 0.1)
    self.T1  = self.Vt * (self.vgfbCV - self.psip - 2.0 * self.qdeff * (self.nq - 1.0))
    self.qbd = self.Smooth(self.T1, 0.0, 0.1)
    self.qb  = 0.5 * (self.qbs + self.qbd)
    self.qia = self.nq * self.Vt * (self.qs + self.qdeff)
    self.Eeffm = self.EeffFactor * (self.qb + self.eta_mu * self.qia)
    self.psip = self.PO_psip((self.vgfbCV + self.DELVFBACC * self.inv_Vt), self.gamCV, self.DPD)
    self.T3    = (self.UA_a + self.UC_a * self.Vbsx) * self.Eeffm**self.EU_t
    self.T4    = 1.0 + self.T3
    self.Dmob = self.Smooth(self.T4, 1.0, 0.0015)
    self.LambdaC = 2.0 * (self.U0_a / self.Dmob) * self.Vt / (self.VSATCV_t * self.Lact)
    self.dps     = self.qs - self.qdeff
    self.T1      = 2.0 * (self.LambdaC * self.dps) * (self.LambdaC * self.dps)
    self.zsat    = sqrt(1.0 + self.T1)
    self.Dvsat   = 0.5 * (1.0 + self.zsat)
    # CLM for C-V
    self.Esat    = 2.0 * self.VSATCV_t / (self.U0_a / self.Dmob)
    self.EsatL   = self.Esat * self.Lact
    self.Vasat   = self.VdssatCV + self.EsatL
    self.diffVds = self.Vds - self.Vdseff
if (self.PCLMCV_i != 0.0):
    self.MdL = 1.0 + self.PCLMCV_i * self.lln(1.0 + self.diffVds / self.PCLMCV_i / self.Vasat)
else:
    self.MdL = 1.0
self.MdL_2       = self.MdL * self.MdL
self.inv_MdL     = 1.0 / self.MdL
self.inv_MdL_2   = 1.0 / self.MdL_2
self.MdL_less_1  = self.MdL - 1.0
self.vgpqm = self.vgfbCV - self.psip
self.DQSD  = (self.qs - self.qdeff)
self.DQSD2 = (self.qs - self.qdeff) * (self.qs - self.qdeff)
self.sis   = self.vgpqm + 2.0 * self.qs
self.sid   = self.vgpqm + 2.0 * self.qdeff
self.T1 = self.Smooth(self.sis, 0.0, 0.5)
self.T2 = self.Smooth(self.sid, 0.0, 0.5)
self.Temps = sqrt(0.25 + self.T1 * self.invgamg2)
self.Tempd = sqrt(0.25 + self.T2 * self.invgamg2)
self.T1 = self.sis / (1.0 + 2.0 * self.Temps)
self.T2 = self.sid / (1.0 + 2.0 * self.Tempd)
self.T3 = self.Temps + self.Tempd
self.T4 = self.Oneby3 * (self.DQSD2 / (self.T3 * self.T3 * self.T3))
self.T5 = (self.ABULK*self.Dvsat * self.inv_MdL) / (1.0 + self.qs + self.qdeff)
self.T6 = 0.8 * (self.T3 * self.T3 + self.Temps * self.Tempd) * self.T5
self.T7 = self.T6 + (2.0 * self.invgamg2)
self.T8 = self.Oneby3 * self.DQSD2 * self.T5
self.dqgeff = self.sid * (2.0 * self.Tempd - 1.0) / (2.0 * self.Tempd + 1.0)
self.qbeff  = self.vgpqm - 2.0 * (self.nq - 1.0) * self.qdeff + self.dqgeff
self.Qb  = self.inv_MdL * (self.T1 + self.T2 + (self.T4 * self.T7 - self.nq * (self.qs + self.qdeff + self.T8))) + self.MdL_less_1 * self.qbeff
self.T9  = self.qs + self.qdeff
self.T10 = self.DQSD2 * self.T5 * self.T5
self.Qi  = self.nq * self.inv_MdL * (self.T9 + self.Oneby3 * self.DQSD2 * self.T5) + 2.0 * self.nq * self.MdL_less_1 * self.qdeff
self.Qd1 = self.nq * self.inv_MdL_2 * (0.5 * self.T9 - (self.DQSD / 6.0) * (1.0 - self.DQSD * self.T5 - 0.2 * self.T10))
self.Qd2 = self.nq * (self.MdL - self.inv_MdL) * self.qdeff
self.Qd  = self.Qd1 + self.Qd2
self.Qs  = self.Qi - self.Qd

# Quantum mechanical effects
self.qbaCV = self.Smooth(self.Vt * self.Qb, 0.0, 0.1)
self.qiaCV      = self.Vt * (self.Qs + self.Qd)
self.T0         = (self.qiaCV + self.ETAQM * self.qbaCV) / self.QM0
self.T1         = 1.0 + self.T0**(0.7 * self.BDOS)
self.XDCinv     = self.ADOS * 1.9e-9 / self.T1
self.Coxeffinv  = 3.9 * self.EPS0 / (self.BSIMBULKTOXP * 3.9 / self.EPSROX + self.XDCinv / self.epsratio)
self.QBi        = -self.NF * self.Wact * self.Lact * (self.EPS0 * self.EPSROX / self.BSIMBULKTOXP) * self.Vt * self.Qb
self.WLCOXVtinv = self.NF * self.Wact * self.Lact * self.Coxeffinv * self.Vt
self.QSi        = -self.WLCOXVtinv * self.Qs
self.QDi        = -self.WLCOXVtinv * self.Qd
self.QGi        = -(self.QBi + self.QSi + self.QDi)

# Outer fringing capacitances
if ("CF" not in param.keys()):
    self.CF_i = 2.0 * self.EPSROX * self.EPS0 / self.M_PI * self.lln(self.CFRCOEFF * (1.0 + 0.4e-6 / self.TOXE))
self.Cgsof = self.CGSO + self.CF_i
self.Cgdof = self.CGDO + self.CF_i

# Overlap capacitances
if (self.COVMOD == 0):
    self.Qovs = -self.Wact * self.NF * self.Cgsof * self.Vgs_ov_noswap
    self.Qovd = -self.Wact * self.NF * self.Cgdof * self.Vgd_ov_noswap
else:
    self.T0    = sqrt((self.Vgs_ov_noswap - self.Vfbsdr + self.DELTA_1) * (self.Vgs_ov_noswap - self.Vfbsdr + self.DELTA_1) + 4.0 * self.DELTA_1)
    self.Vgsov = 0.5 * (self.Vgs_ov_noswap - self.Vfbsdr + self.DELTA_1 - self.T0)
    self.T1    = sqrt(1.0 - 4.0 * self.Vgsov / self.CKAPPAS_i)
    self.Qovs  = -self.Wact * self.NF * (self.Cgsof * self.Vgs_ov_noswap + self.CGSL_i * (self.Vgs_ov_noswap - self.Vfbsdr - self.Vgsov - 0.5 * self.CKAPPAS_i * (-1.0 + self.T1)))
    self.T0    = sqrt((self.Vgd_ov_noswap - self.Vfbsdr + self.DELTA_1) * (self.Vgd_ov_noswap - self.Vfbsdr + self.DELTA_1) + 4.0 * self.DELTA_1)
    self.Vgdov = 0.5 * (self.Vgd_ov_noswap - self.Vfbsdr + self.DELTA_1 - self.T0)
    self.T2    = sqrt(1.0 - 4.0 * self.Vgdov / self.CKAPPAD_i)
    self.Qovd  = -self.Wact * self.NF * (self.Cgdof * self.Vgd_ov_noswap + self.CGDL_i * (self.Vgd_ov_noswap - self.Vfbsdr - self.Vgdov - 0.5 * self.CKAPPAD_i * (-1.0 + self.T2)))
self.Qovb = -self.devsign * self.NF * self.Lact * self.CGBO * (self.Vg - self.Vb)
self.Qovg = -(self.Qovs + self.Qovd + self.Qovb)

# Edge FET model
if (self.EDGEFET == 1):
    self.phib_edge     = self.lln(self.NDEPEDGE_i / self.ni)
    self.Phist         = max(0.4 + self.Vt * self.phib_edge + self.PHIN_i, 0.4)
    self.sqrtPhist     = sqrt(self.Phist)
    self.T1DEP         = sqrt(2.0 * self.epssi / (self.q * self.NDEPEDGE_i))
    self.NFACTOREDGE_t = self.NFACTOREDGE_i * self.hypsmooth((1.0 + self.TNFACTOREDGE_i * (self.TRatio - 1.0)), 1e-3)
    self.ETA0EDGE_t    = self.ETA0EDGE_i * (1.0 + self.TETA0EDGE_i * (self.TRatio - 1.0))
    self.PhistVbs = self.Smooth(self.Phist - self.Vbsx, 0.05, 0.1)
    self.sqrtPhistVbs  = sqrt(self.PhistVbs)
    self.Xdep          = self.T1DEP * self.sqrtPhistVbs
    self.Cdep          = self.epssi / self.Xdep
    self.cdsc          = self.CITEDGE_i + self.NFACTOREDGE_t + self.CDSCDEDGE_i * self.Vdsx - self.CDSCBEDGE_i * self.Vbsx
    self.T1            = 1.0 + self.cdsc/self.Cox
    self.n = self.Smooth(self.T1, 1.0, 0.05)
    self.nVt       = self.n * self.Vt
    self.inv_nVt   = 1.0 / self.nVt
    self.vg        = self.Vg * self.inv_nVt
    self.vs        = self.Vs * self.inv_nVt
    self.vfb       = self.VFB_i * self.inv_nVt
    self.dvth_dibl = -(self.ETA0EDGE_t + self.ETABEDGE_i * self.Vbsx) * self.Vdsx
    self.dvth_temp = (self.KT1EDGE_i + self.KT1LEDGE_i / self.Leff + self.KT2EDGE_i * self.Vbsx) * (self.TRatio**self.KT1EXPEDGE_i - 1.0)
    self.litl_edge = self.litl * (1.0 + self.DVT2EDGE * self.Vbsx)
    self.T0        = self.DVT1EDGE * self.Leff / self.litl_edge
    if (self.T0 < 40.0):
        self.theta_sce_edge = 0.5 * self.DVT0EDGE / (cosh(self.T0) - 1.0)
    else:
        self.theta_sce_edge = self.DVT0EDGE * self.lexp(-self.T0)
    self.dvth_sce  = self.theta_sce_edge * (self.Vbi_edge - self.Phist)
    self.Vth_shift = self.dvth_dibl - self.dvth_temp + self.dvth_sce + self.DVTEDGE + self.vth0_stress_EDGE - self.K2EDGE_i * self.Vbsx
    self.vgfb      = self.vg - self.vfb - self.Vth_shift * self.inv_nVt

    # Normalized body factor
    self.DGAMMAEDGE_i = self.DGAMMAEDGE * (1.0 + self.DGAMMAEDGEL * self.Leff**-self.DGAMMAEDGELEXP)
    self.gam_edge          = sqrt(2.0 * self.q * self.epssi * self.NDEPEDGE_i * self.inv_nVt) / self.Cox
    self.gam_edge          = self.gam_edge * (1.0 + self.DGAMMAEDGE_i)
    self.inv_gam           = 1.0 / self.gam_edge

    # psip: pinch-off voltage
    self.phib_n_edge  = self.phib_edge / self.n
    self.psip = self.PO_psip(self.vgfb, self.gam_edge, 0.0)
    self.qs_edge = self.BSIM_q(self.psip, self.phib_n_edge, self.vs, self.gam_edge)

    # Approximate pinch-off voltage
    self.vdsatedge = 2.0 * self.nVt * self.qs_edge + 2.0 * self.nVt
    self.Vdsatedge = self.vdsatedge
    self.Vdsatedge = self.Vdsatedge + self.Vs

    # Vdssat clamped to avoid negative values during transient simulation
    self.Vdssate = self.Smooth(self.Vdsatedge - self.Vs, 0.0, 1.0e-3)
    self.T7     = (self.Vds / self.Vdssate)**(1.0 / self.DELTA_t)
    self.T8     = (1.0 + self.T7)**-self.DELTA_t
    self.Vdseff = self.Vds * self.T8
    self.vdeff  = (self.Vdseff + self.Vs) * self.inv_nVt
    self.qdeff_edge = self.BSIM_q(self.psip, self.phib_n_edge, self.vdeff, self.gam_edge)

    # Nq calculation for Edge FET
    self.psipclamp = self.Smooth(self.psip, 1.0, 2.0)
    self.sqrtpsip = sqrt(self.psipclamp)
    self.psiavg   = self.psip - self.qs_edge - self.qdeff_edge -1.0
    self.T0 = self.Smooth(self.psiavg, 1.0, 2.0)
    self.T2       = sqrt(self.T0)
    self.nq_edge  = 1.0 + self.gam_edge / (self.sqrtpsip + self.T2)
    self.ids_edge = 2.0 * self.NF * self.nq_edge * self.ueff * self.WEDGE / self.Leff * self.Cox * self.nVt * self.nVt * ((self.qs_edge - self.qdeff_edge) * (1.0 + self.qs_edge + self.qdeff_edge)) * self.Moc
    self.ids      = self.ids_edge + self.ids
